<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[如何用电脑安装黑群晖NAS]]></title>
    <url>%2Fposts%2Fd8d185fd%2F</url>
    <content type="text"><![CDATA[电脑主板:QOTOM Q3XX镜像下载地址：http://down.nas2x.com/synology/dsm/ 不要使用太新的版本，推荐6.1.7 12DSM_DS3617xs_15284.pat 21-May-2018 10:30 247Msynoboot.img 15-Jul-2017 18:15 50M U盘安装方法 下载安装ChipEasy，记录VID和PID 下载安装OSFMount，用来修改镜像 2.1 左下角点击mount new ，然后选中下载的synoboot .img镜像 2.2 选择Part0选项 2.3 去掉Read-only选框 2.4 双击生成的虚拟镜像 2.5 修改grub.cfg文件，将下面的两个参数修改为chipeasy读取到的 2.6 修改sn和mac1可以用于洗白NAS，保存退出 将镜像写入到U盘 用Rufus工具将镜像写入U盘 硬盘安装方法使用SATA转USB接入电脑，用Rufus工具将镜像写入硬盘即可 安装过程演示的是U盘安装方法 因为我没有修改BIOS启动项，所以这里手动选择启动项；U盘插入电脑，看到开机Logo后按F11（不同主板快捷键不同）进入启动项选择，选择U盘 选择第一项进入 成功进入后会出现如下界面 浏览器输入http://find.synology.com/，回车访问，网页就会自动搜索同一局域网下的群晖设备 点击图片后开始进行设置，点击手动安装 选择下载的DSM_DS3617xs_15284.pat，立即安装 安装过程如下，需要几分钟 然后进行账号的设置 不要自动更新 这里点击直接跳过就好，这是给正版透传用的，我们想要内网穿透用frp、花生壳或者端口转发就行了 安装完成，界面如下 最后安装完成后别升级，不然可能会导致出现问题！！！]]></content>
      <categories>
        <category>NAS</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt安装V2Ray科学上网]]></title>
    <url>%2Fposts%2Fc019c9fa%2F</url>
    <content type="text"><![CDATA[为什么我要在软路由中安装V2Ray，为的就是想要更方便的科学上网，脱离V2Ray客户端的束缚，并且软路由能大大提高翻墙速度。 下图是油管一些播主的对比图，速度足足快了几倍。 工控机型号：QOTOM Q3XXG4 OpenWrt系统版本如下： 进入酷软安装V2Ray，软件已经下架了，只能使用离线安装了。 设置V2Ray 打开代理 代理模式设置为大陆白名单，我的服务类型为自建，然后复制自建VPS的配置文件提交即可，成功后运行状态会打勾。 然后在手动更新下规则 配置完后重启下V2Ray插件即可，谷歌、油管都可以上了，并且速度非常快（前提自己宽带给力） V2Ray链接：https://pan.baidu.com/s/1pyEhG4cf2nkxqhHp6bb8mw提取码：2j3a]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>OpenWrt</tag>
        <tag>Koolshare</tag>
        <tag>V2Ray</tag>
        <tag>VPN</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建V2Ray实现科学上网(下)]]></title>
    <url>%2Fposts%2F198de251%2F</url>
    <content type="text"><![CDATA[VPS的购买请看上一篇文章《搭建V2Ray实现科学上网(上)》 购买服务器服务器位置选择洛杉矶，速度比稳定，也可以自行测试适合自己的，下面是测试地址 数据中心 测试 IP 测试文件 演示地址 日本东京 108.61.201.151 100MB 1000MB http://hnd-jp-ping.vultr.com 新加坡 45.32.100.168 100MB 1000MB http://sgp-ping.vultr.com 荷兰阿姆斯特丹 108.61.198.102 100MB 1000MB http://ams-nl-ping.vultr.com 法国巴黎 108.61.209.127 100MB 1000MB http://par-fr-ping.vultr.com 德国法兰克福 108.61.210.117 100MB 1000MB http://fra-de-ping.vultr.com 英国伦敦 108.61.196.101 100MB 1000MB http://lon-gb-ping.vultr.com 美国达拉斯 108.61.224.175 100MB 1000MB http://tx-us-ping.vultr.com 美国西雅图 108.61.194.105 100MB 1000MB http://wa-us-ping.vultr.com 美国芝加哥 107.191.51.12 100MB 1000MB http://il-us-ping.vultr.com 美国亚特兰大 108.61.193.166 100MB 1000MB http://ga-us-ping.vultr.com 美国洛杉矶 108.61.219.200 100MB 1000MB http://lax-ca-us-ping.vultr.com 美国迈阿密 104.156.244.232 100MB 1000MB http://fl-us-ping.vultr.com 美国纽约 108.61.149.182 100MB 1000MB http://nj-us-ping.vultr.com 美国硅谷 104.156.230.107 100MB 1000MB http://sjo-ca-us-ping.vultr.com 澳大利亚悉尼 108.61.212.117 100MB 1000MB http://syd-au-ping.vultr.com 服务器选择Cent OS，因为送的$50有效期只有30天，所以这里选了$40/mo，不用白不用嘛。 账号默认root，密码是随机生成的 接下来就是登陆VPS服务器，推荐使用xshell，这个就自行百度下载了。 建立会话，配置好地址，账号密码连接即可，如下图： 安装V2ray1、安装curl 1yum update -y &amp;&amp; yum install curl -y 2、v2ray一键安装配置脚本 1bash &lt;(curl -s -L https://git.io/v2ray.sh) 3、安装步骤 选择1进行安装 传输协议默认TCP即可 端口[xxx]，默认或者自行设置 拦截广告，默认[N] 是否配置 Shadowsocks ，默认[N] 配置信息路径：/etc/v2ray/config.json 查看是否开机启动（默认v2ray开机启动） 1systemctl list-unit-files|grep v2ray 如果没有开机启动，输入下面指令 12systemctl enable v2raysystemctl start v2ray 打开防火墙v2ray的端口默认是会被防火墙拦截的，一定要添加打开端口，这个很重要 12firewall-cmd --zone=public --add-port=端口号/tcp --permanentfirewall-cmd --reload 开启BBR加速脚本需要内核为4.1以上，如果服务器类型选择cent os 8那么应该已经自带了，我选用的centos 7，这里需要安装下，输入以下命令： 123wget --no-check-certificate https://github.com/teddysun/across/raw/master/bbr.shchmod +x bbr.sh./bbr.sh 安装完成后，脚本会提示需要重启 VPS，输入 y 并回车后重启 lsmod|grep bbr 查看BBR是否启用，如果输出tcp_bbr模块说明BBR已启动 开启bbr后速度提升非常明显， https://github.com/sivel/speedtest-cli.git V2Ray客户端配置Windows客户端 V2RayW V2RayW-v1.0.0-beta2 V2RayW Git V2RayN V2RayN-v2.53 V2RayN Git V2RayS V2RayS_v1.0.0.3 V2RayS Git 安卓客户端 V2RayNG V2RayNG -v1.1.12 V2RayNG Git Mac客户端 V2RayX V2RayX- v1.5.1 V2RayX Git V2RayU V2RayU-v1.5.1 V2RayU Git 下面以Windows平台的V2RayW/V2rayN为例说明客户端的配置和使用方法： V2RayW 打开应用后右键托盘内的V2ray图标，点击“配置” 在VMess服务器点击“增加”，在服务器信息分别输入 服务器ip、端口号、用户ID、额外ID，如下图： 右击V2ray图标，选择自动模式(PAC)，然后就可以正确的上网了。 V2RayNV2RayN配置更简单 VPS控制台输入v2ray url 生成vemss URL，copy到内存 打开V2RayN客户端，点击左上角服务器——&gt;从剪贴板导入URL 最后右键V2rayN客户端，选择http代理，推荐PAC，如果正常的话，那么已经可以科学上网了 V2Ray相关命令12345678910111213141516v2ray info //查看 V2Ray 配置信息v2ray config //修改 V2Ray 配置v2ray link //生成 V2Ray 配置文件链接v2ray infolink //生成 V2Ray 配置信息链接v2ray qr //生成 V2Ray 配置二维码链接v2ray ss //修改 Shadowsocks 配置v2ray ssinfo //查看 Shadowsocks 配置信息v2ray ssqr //生成 Shadowsocks 配置二维码链接v2ray status //查看 V2Ray 运行状态v2ray start //启动 V2Rayv2ray stop //停止 V2Rayv2ray restart //重启 V2Rayv2ray log //查看 V2Ray 运行日志v2ray update //更新 V2Rayv2ray update.sh //更新 V2Ray 管理脚本v2ray uninstall //卸载 V2Ray]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
        <tag>VPN</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建V2Ray实现科学上网(上)]]></title>
    <url>%2Fposts%2F96d310%2F</url>
    <content type="text"><![CDATA[前言​ V2Ray(Project V) 相对于 Shadowsocks，V2Ray 更像全能选手，拥有更多可选择的协议 / 传输载体 (Socks、HTTP、TLS、TCP、mKCP、WebSocket )，还有强大的路由功能，不仅仅于此，它亦包含 Shadowsocks 组件，你只需要安装 V2Ray，你就可以使用所有的 V2Ray 相关的特性包括使用 Shadowsocks，由于 V2Ray 是使用 GO 语言所撰写的，天生的平台部署优势，部署好服务端后，下载即可使用。 注册新用户​ 首先需要购买一个VPS用来搭建V2Ray，这里推荐使用VULTR的VPS，选择洛杉矶（延时低），可支付宝，微信付款； 新用户注册激活送$50 : https://www.vultr.com（赠送金额有效期30天）新用户注册送$10: https://www.vultr.com/?ref=8337083（充值10$送10$）新用户注册送$25: https://www.vultr.com/?ref=8337083（充值25$送25$） 激活账号注册成功后， VULTR 会发送一封验证邮箱的邮件，点击验证就可以了。 ​ 「新用户」注册后，进入后台的「Billing」页面，充值 10 美元 (支付宝 / 微信支付 / PayPal 等渠道至少充值 10 美元) 才能激活账号。 你的账号必须充值后才算“激活”完成，才能获赠使用金。 充值后赠送金额基本立马就可以到账。 Vultr赠送金额扣费方式主要为2种： 优先扣赠送金额这种扣费方式的意思就是会先扣你的赠送金额，扣完才会扣你充值的钱。Vultr充$10送$10以及目前的新用户充值送$50美元都是这种扣费方式。 一半扣账户余额，一半扣赠送金额这种扣费方式就是一半扣你充值的钱，一半扣赠送金额。Vultr的充多少送多少就是这种扣费方式，简单点说，加入你一个月用了10美元，那么5美元来自你的充值，5美元来自赠送金额。 另外绑定推特还有赠金送，不要忘记领取 下一步搭建V2Ray服务器]]></content>
      <categories>
        <category>科学上网</category>
      </categories>
      <tags>
        <tag>V2Ray</tag>
        <tag>VPN</tag>
        <tag>VPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WPF程序实现多语言支持 动态加载资源词典]]></title>
    <url>%2Fposts%2Fa747d650%2F</url>
    <content type="text"><![CDATA[创建资源词典，首先新建两个词典文件en-us.xaml、zh-cn.xaml zh-cn.xaml： 123456789&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:GPIO_TOOL_WIN&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot;&gt; &lt;s:String x:Key=&quot;buttonTest1&quot;&gt;测试按钮1&lt;/s:String&gt; &lt;s:String x:Key=&quot;buttonTest2&quot;&gt;测试按钮2&lt;/s:String&gt; &lt;s:String x:Key=&quot;buttoncn&quot;&gt;中文&lt;/s:String&gt; &lt;s:String x:Key=&quot;buttonen&quot;&gt;英文&lt;/s:String&gt;&lt;/ResourceDictionary&gt; en-us.xaml: 123456789&lt;ResourceDictionary xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:TEST_TOOL_WIN&quot; xmlns:s=&quot;clr-namespace:System;assembly=mscorlib&quot;&gt; &lt;s:String x:Key=&quot;buttonTest1&quot;&gt;Button TEST1&lt;/s:String&gt; &lt;s:String x:Key=&quot;buttonTest2&quot;&gt;Button TEST2&lt;/s:String&gt; &lt;s:String x:Key=&quot;buttoncn&quot;&gt;Chinese&lt;/s:String&gt; &lt;s:String x:Key=&quot;buttonen&quot;&gt;English&lt;/s:String&gt;&lt;/ResourceDictionary&gt; 将两个资源词典添加到App.xaml中 1234567891011121314&lt;Application x:Class=&quot;GPIO_TOOL_WIN.App&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:local=&quot;clr-namespace:TEST_TOOL_WIN&quot; StartupUri=&quot;MainWindow.xaml&quot;&gt; &lt;Application.Resources&gt; &lt;ResourceDictionary&gt; &lt;ResourceDictionary.MergedDictionaries&gt; &lt;ResourceDictionary Source=&quot;Resources\en-us.xaml&quot; /&gt; &lt;ResourceDictionary Source=&quot;Resources\zh-cn.xaml&quot; /&gt; &lt;/ResourceDictionary.MergedDictionaries&gt; &lt;/ResourceDictionary&gt; &lt;/Application.Resources&gt;&lt;/Application&gt; 在界面设计器中需要显示的位置添加动态资源，例如： 123456789101112131415&lt;Window x:Class=&quot;GPIO_TOOL_WIN.MainWindow&quot; xmlns=&quot;http://schemas.microsoft.com/winfx/2006/xaml/presentation&quot; xmlns:x=&quot;http://schemas.microsoft.com/winfx/2006/xaml&quot; xmlns:d=&quot;http://schemas.microsoft.com/expression/blend/2008&quot; xmlns:mc=&quot;http://schemas.openxmlformats.org/markup-compatibility/2006&quot; xmlns:local=&quot;clr-namespace:TEST_TOOL_WIN&quot; mc:Ignorable=&quot;d&quot; Title=&quot;WPF TEST&quot; Height=&quot;450&quot; Width=&quot;800&quot;&gt; &lt;Grid&gt; &lt;Button x:Name=&quot;buttonTest1&quot; Content=&quot;&#123;DynamicResource buttonTest1&#125;&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;20,20,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;100&quot;/&gt; &lt;Button x:Name=&quot;buttonTest2&quot; Content=&quot;&#123;DynamicResource buttonTest2&#125;&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;20,50,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;100&quot;/&gt; &lt;Button x:Name=&quot;buttoncn&quot; Content=&quot;&#123;DynamicResource buttoncn&#125;&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;20,150,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;75&quot; Click=&quot;Buttoncn_Click&quot;/&gt; &lt;Button x:Name=&quot;buttonen&quot; Content=&quot;&#123;DynamicResource buttonen&#125;&quot; HorizontalAlignment=&quot;Left&quot; Margin=&quot;120,150,0,0&quot; VerticalAlignment=&quot;Top&quot; Width=&quot;75&quot; Click=&quot;Buttonen_Click&quot;/&gt; &lt;/Grid&gt;&lt;/Window&gt; 切换语言代码如下： 123456789List&lt;ResourceDictionary&gt; dictionaryList = new List&lt;ResourceDictionary&gt;(); foreach (ResourceDictionary dictionary in Application.Current.Resources.MergedDictionaries) &#123; dictionaryList.Add(dictionary); &#125; string requestedCulture = @&quot;Resources\en-us.xaml&quot;; ResourceDictionary resourceDictionary = dictionaryList.Find(d =&gt; d.Source.OriginalString.Equals(requestedCulture)); Application.Current.Resources.MergedDictionaries.Remove(resourceDictionary); Application.Current.Resources.MergedDictionaries.Add(resourceDictionary); 测试效果如下图：]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu systemd rc.local 如何设置开机启动]]></title>
    <url>%2Fposts%2F110ed71d%2F</url>
    <content type="text"><![CDATA[转载：http://iqotom.com/?p=965 前言Ubuntu18.04不再使用initd管理系统，改用systemd，现在已成为大多数发行版的标准配置。 以前Linux启动一直采用init进程，例如： 12sudo /etc/init.d/apache2 startservice apache2 start 这种方法有两个缺点： 一是启动时间长。init进程是串行启动，只有前一个进程启动完，才会启动下一个进程 二是启动脚本复杂。init进程只是执行启动脚本，不管其他事情。脚本需要自己处理各种情况，这往往使得脚本变得很长 Systemd 就是为了解决这些问题而诞生的。它的设计目标是，为系统的启动和管理提供一套完整的解决方案。 根据 Linux 惯例，字母d是守护进程（daemon）的缩写。 Systemd 这个名字的含义，就是它要守护整个系统。 Systemd 的优点是功能强大，但是缺点也很明显，体系庞大，非常复杂。事实上，现在还有很多人反对使用 。 这里记录下，跟以前一样在/etc/rc.local设置开机启动程序，加载驱动 Setp.1systemd默认读取/etc/systemd/system下的配置文件，该目录下的文件会链接/lib/systemd/system/下的文件。一般系统安装完/lib/systemd/system/下会有rc-local.service文件，即我们需要的配置文件。 链接过来： 1234cd /lib/systemd/systemln -fs /lib/systemd/system/rc-local.service /etc/systemd/system/rc-local.servicecd /etc/systemd/systemcat rc-local.service rc-local.service内容： 1234567891011121314151617181920212223# SPDX-License-Identifier: LGPL-2.1+## This file is part of systemd.## systemd is free software; you can redistribute it and/or modify it# under the terms of the GNU Lesser General Public License as published by# the Free Software Foundation; either version 2.1 of the License, or# (at your option) any later version.# This unit gets pulled automatically into multi-user.target by# systemd-rc-local-generator if /etc/rc.local is executable.[Unit]Description=/etc/rc.local CompatibilityDocumentation=man:systemd-rc-local-generator(8)ConditionFileIsExecutable=/etc/rc.localAfter=network.target[Service]Type=forkingExecStart=/etc/rc.local startTimeoutSec=0RemainAfterExit=yesGuessMainPID=no [Unit] 区块：启动顺序与依赖关系。 [Service] 区块：启动行为,如何启动，启动类型。 Setp.2 创建/etc/rc.local文件 1touch /etc/rc.local 赋予可执行权限 1chmod 755 rc.local 编辑rc.local，添加需要开机启动的任务 123#!/bin/bashecho &quot;test rc!!!&quot; &gt; /var/test_rc.log reboot重启系统，查看/var目录已经成了test_rc.log]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>systemd</tag>
        <tag>rc.local</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux压力测试工具stress如何使用]]></title>
    <url>%2Fposts%2Fd0639c77%2F</url>
    <content type="text"><![CDATA[转载：http://iqotom.com/?p=969 下载安装stress1apt install stress stress工具使用先介绍下stress的命令参数 1234567891011121314151617181920212223`stress&apos; imposes certain types of compute stress on your systemUsage: stress [OPTION [ARG]] ... -?, --help show this help statement --version show version statement -v, --verbose be verbose -q, --quiet be quiet -n, --dry-run show what would have been done -t, --timeout N timeout after N seconds --backoff N wait factor of N microseconds before work starts -c, --cpu N spawn N workers spinning on sqrt() -i, --io N spawn N workers spinning on sync() -m, --vm N spawn N workers spinning on malloc()/free() --vm-bytes B malloc B bytes per vm worker (default is 256MB) --vm-stride B touch a byte every B bytes (default is 4096) --vm-hang N sleep N secs before free (default none, 0 is inf) --vm-keep redirty memory instead of freeing and reallocating -d, --hdd N spawn N workers spinning on write()/unlink() --hdd-bytes B write B bytes per hdd worker (default is 1GB)Example: stress --cpu 8 --io 4 --vm 2 --vm-bytes 128M --timeout 10sNote: Numbers may be suffixed with s,m,h,d,y (time) or B,K,M,G (size). 参数说明： -? 显示帮助信息 -v 显示版本号 -q 不显示运行信息 -n 显示已完成的指令情况 -t –timeout N 指定运行N秒后停止 –backoff N 等待N微妙后开始运行 -c 产生n个进程 每个进程都反复不停的计算随机数的平方根 -i 产生n个进程 每个进程反复调用sync()，sync()用于将内存上的内容写到硬盘上 -m –vm n 产生n个进程,每个进程不断调用内存分配malloc和内存释放free函数 –vm-bytes B 指定malloc时内存的字节数 （默认256MB） –vm-hang N 指定在free钱的秒数 -d –hadd n 产生n个执行write和unlink函数的进程 -hadd-bytes B 指定写的字节数 –hadd-noclean 不unlink 时间单位可以为秒s，分m，小时h，天d，年y，文件大小单位可以为K，M，G 测试场景举例： 测试CPU负荷 输入命令：stress -c 4 -t 10 增加4个cpu进程，处理sqrt()函数函数，以提高系统CPU负荷，测试10s 内存测试 输入命令：stress -i 4 –vm 10 –vm-bytes 1G –vm-hang 100 –timeout 100s 新增4个io进程，10个内存分配进程，每次分配大小1G，分配后不释放，测试100S 磁盘I/O测试 输入命令：stress -d 1 –hdd-bytes 3G 新增1个写进程，每次写3G文件块 硬盘测试（不删除） 输入命令：stress -i 1 -d 10 –hdd-bytes 3G -hdd-noclean 新增1个IO进程，10个写进程，每次写入3G文件块，且不清除，会逐步将硬盘耗尽 安装htop监控进程12apt install htop#htop的具体使用方法请自行搜索 安装sensors监控温度123456apt install lm-sensors#输入sensors即可检测温度和风扇转速root@ubuntu:~# sensors|grep -E &apos;Core|Package&apos;Package id 0: +46.0°C (high = +100.0°C, crit = +100.0°C)Core 0: +42.0°C (high = +100.0°C, crit = +100.0°C)Core 1: +44.0°C (high = +100.0°C, crit = +100.0°C) 测试脚本输入测试时间，每秒钟打印当前CPU温度 123456789101112#!/bin/shecho -n &quot;Input test time:&quot;read TIMEecho &quot;===================STRESS TEST START===================&quot;stress -c 4 -t $TIME &amp;while [ &quot;$TIME&quot; -gt 0 ]; do sensors|grep -E &quot;Package|Core&quot; sleep 1 TIME=$(($TIME-1)) echo &quot;==============================time:$TIME&quot;done 测试截屏]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>stress</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[如何用VS打包发布Winform程序并设置开机启动]]></title>
    <url>%2Fposts%2Feee045de%2F</url>
    <content type="text"><![CDATA[系统：Windows10 x64 工具：Visual Studio 2017 首先需要确保VS安装了Visual Studio Installer Project（菜单栏——工具——扩展和更新） 打包步骤 新建Installer项目 右键Application Folder添加文件，将主程序和库文件上传，比如我的程序叫appname.exe 创建程序桌面快捷方式 右键主程序，选择Create Shortcut to appname.exe，将生成的快捷方式剪贴到User&#39;s Desktop 创建程序开始菜单 4.1 程序快速启动图标 这个跟创建桌面快捷方式的方法一样 4.2 程序卸载图标 a.将`C\Windows\System32\msiexec.exe`上传到`Applicaiton Folder` b.对`msiexec.exe`重命名下，一般改名为`“Uninstall.exe”`，然后创建快捷方式到`User&apos;s Programs Menu` 4.3 设置卸载参数，告诉卸载程序应该卸载哪个程序 ​ a. 在属性里面找到安装项目的ProductCode ​ b. 然后点击Uninstall程序，修改属性参数Arguments，值为&quot;/x ProductCode&quot; 设置开机启动用修改注册表的方式来设置开机启动 右键项目——View——注册表 添加如下字段到LOCAL_MACHINE，这个是所有用户，CURRENT_USER应该也可以（没测试过）\HKEY_LOCAL_MACHINE\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run 设置系统必备一般我们开发的Winform程序都有一个目标框架，就是所依赖的.Net Framework版本环境，如.Net Framework 2.0/3.5/4.0/4.5等 要想我们的程序在电脑上正常运行，首先就得保证系统上装有指定的.net Framework版本框架，可以在安装包的属性中设置，启动安装前检查操作系统中是否安装了指定版本的框架或其他依赖，设置方法如下： 右键安装包项目，点开“Prerequisites” 选择“从组件供应商的网站上下载系统必备组件”，这样一来，即使电脑上没有安装需要的.net Framework也不要紧，只要设置了这项，安装程序会自动从微软的官网上下载对应的组件并安装 生成安装文件右键安装项目，选择重新生成 如果不出错，那么会在项目的Debug或Release文件夹生成安装文件 setup.exe里边包含了对安装程序的一些条件的检测，比如.net的版本是否支持，当条件具备后，setup.exe接着调用setup.msi进行安装。如果你确定条件都具备的话也可以直接运行setup.msi进行安装]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu下使用脚本打包QT程序]]></title>
    <url>%2Fposts%2F929948af%2F</url>
    <content type="text"><![CDATA[Ubuntu版本：18.04 QT版本：5.7.0 例如程序名为GPIO-TEST 找个目录创建文件夹用来存放打包的程序，/zdisk/MY_GPIO-TEST 将工程用Release模式编译，直接运行项目就行了 打开编译出文件夹的文件，我的路径如下： /zdisk/qt-project/build-GPIO-TEST-Desktop_Qt_5_7_0_GCC_64bit-Release 在Release文件夹创建文件copylib.sh，并修改权限为777，文件内容如下： 12345678910LibDir=$PWD&quot;/lib&quot;Target=$1lib_array=($(ldd $Target | grep -o &quot;/.*&quot; | grep -o &quot;/.*/[^[:space:]]*&quot;))$(mkdir $LibDir)for Variable in $&#123;lib_array[@]&#125;do cp &quot;$Variable&quot; $LibDir 打开终端进到当前文件夹，输入./copylib.sh GPIO-TEST，会产生一个lib文件夹，这里称为GPIO-TEST库文件 脚本实际上是调用了ldd GPIO-TEST指令获得GPIO-TEST运行时需要哪些库，并将库都复制放到当前目录的lib文件夹中 将GPIO-TEST的二进制文件和GPIO-TEST的库文件夹里的所有的文件复制到MY_GPIO-TEST文件夹中 进入QT的安装目录，找到platforms文件夹，我的路径如下： /opt/Qt5.7.0/5.7/gcc_64/plugins/platforms 将上文的copylib.sh放到platforms文件夹中，并运行./copylib.sh libqxcb.so，这时会得到libqxcb.so的库文件夹 将libqxcb.so的库文件夹的所有文件和platforms文件夹复制到MY_GPIO-TEST文件夹中 在MY_GPIO-TEST文件夹中新建脚本GPIO-TEST.sh,执行chmod 777 GPIO-TEST.sh,并在其中加入如下代码： 123456789101112#!/bin/shappname=`basename $0 | sed s,\.sh$,,`dirname=`dirname $0`tmp=&quot;$&#123;dirname#?&#125;&quot;if [ &quot;$&#123;dirname%$tmp&#125;&quot; != &quot;/&quot; ]; thendirname=$PWD/$dirnamefiLD_LIBRARY_PATH=$dirnameexport LD_LIBRARY_PATH$dirname/$appname &quot;$@&quot; 到这里就基本完成了，将MY_GPIO-TEST文件夹复制到需要运行程序的目标主机即可，在目标主机中，运行程序，都采用 ./GPIO-TEST.sh 而不是./GPIO-TEST，即运行程序的sh脚本，而不是二进制文件 以上就是在ubuntu下使用脚本打包QT程序的方法！ 参考链接：https://blog.csdn.net/z3512498/article/details/64922180]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>QT</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WinRing0如何使用]]></title>
    <url>%2Fposts%2Fb67a6f8b%2F</url>
    <content type="text"><![CDATA[WinRing0 介绍WinRing0 是一个完全免费开源的组件( BSD License ), 允许windows程序直接对I/O端口进行存取操作。通过使用一种内核模式的设备驱动器和其它几种底层编程技巧，它绕过了Windows系统的保护机制。 这里简单写一个读取SIO芯片型号、CPU风扇转速的小程序作为例子 开发环境主板：QOTOM Q6XXG2-P 开发工具：Visual studio 2017 Windows 10 WinRing0 请自行google下载 准备工作 新建项目，省略… 将下载好的WinRing0驱动文件放到项目/bin/Debug目录 将OpenLibSys.cs放到项目根目录 编码代码太多这里只贴出一些关键点 创建一个TestByWinRing0类，用来调用WinRing0的接口，先初始化 12345public bool Initialize()&#123; MyOls = new OpenLibSys.Ols(); return MyOls.GetStatus() == (uint)OpenLibSys.Ols.Status.NO_ERROR;&#125; 根据SuperIO(IT8786)芯片手册查找需要的IO端口 sio芯片入口地址（87,01,55,55） 1234567public void InitSuperIO()&#123; MyOls.WriteIoPortByte(SuperIO.REG, 0x87); MyOls.WriteIoPortByte(SuperIO.REG, 0x01); MyOls.WriteIoPortByte(SuperIO.REG, 0x55); MyOls.WriteIoPortByte(SuperIO.REG, 0x55);&#125; 读取SIO芯片型号 芯片型号是16位，由两个字节组成地址20h,21h 123456789private static int SuperIo_Inw(byte data)&#123; int val; MyOls.WriteIoPortByte(0x2e, data++); val = MyOls.ReadIoPortByte(0x2f) &lt;&lt; 8; MyOls.WriteIoPortByte(0x2e, data); val |= MyOls.ReadIoPortByte(0x2f); return val;&#125; 配置风扇控制寄存器，风扇属于环境控制器，LDN=04h，控制器激活地址30h EC控制器基地址是16位，两个字节，分别由高位60h，低位61h组成 配置寄存器地址Base+05h，配置寄存器数据地址Base+06h 配置风扇转速控制寄存器，地址0C 123456789101112public void InitEc()&#123; MyOls.WriteIoPortByte(0x2e, 0x07); MyOls.WriteIoPortByte(0x2f, 0x04); MyOls.WriteIoPortByte(0x2e, 0x30); MyOls.WriteIoPortByte(0x2f, 0x01); ushort ec_base = (ushort)SuperIo_Inw(0x60); ec_addr_port = (ushort)(ec_base + 0x05); ec_data_port = (ushort)(ec_base + 0x06); MyOls.WriteIoPortByte(ec_addr_port, 0x0c); MyOls.WriteIoPortByte(ec_data_port, 0x00);&#125; 读取风扇转速 风扇转速保存在16位数据里，由两个8位数据保存 上面提到转速控制寄存器，使用的第一组风扇，地址0e 风扇转速计算公式 123456789101112131415161718public int GetFanRpm()&#123; int fan_speed = 0; int fan_rpm = 0; //2-3 Reading Registers[7:0] (Index=0Eh-0Fh) MyOls.WriteIoPortByte(ec_addr_port, 0x0e); byte lval = MyOls.ReadIoPortByte(ec_data_port); //2-3 Extended Reading Registers [15:8] (Index=19h-1Ah) MyOls.WriteIoPortByte(ec_addr_port, 0x19); byte mval = MyOls.ReadIoPortByte(ec_data_port); fan_speed = (mval &lt;&lt; 8) | lval; Console.WriteLine(&quot;fan_speed:&quot; + fan_speed); fan_rpm = (int)(1.35 * Math.Pow(10, 6) / (fan_speed * 2)); return fan_rpm;&#125; 程序运行效果如下]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>WinRing0</tag>
        <tag>c#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux系统下简单实现一个Watchdog]]></title>
    <url>%2Fposts%2Ffe902d45%2F</url>
    <content type="text"><![CDATA[定义看门狗，又叫watchdog timer，是一个定时器电路，一般有一个输入，叫喂狗(kicking the dog/service the dog），一个输出到MCU的RST端，MCU正常工作的时候，每隔一段时间输出一个信号到喂狗端，给 WDT清零，如果超过规定的时间不喂狗（一般在程序跑飞时），WDT定时超过，就会给出一个复位信号到MCU，使MCU复位。防止MCU死机. 看门狗的作用就是防止程序发生死循环，或者说程序跑飞。 基本原理看门狗是一种监控系统的运行状况的手段，通过软硬件结合的方式实现对系统运行状况的监控。稳定运行的软件会在执行完特定指令后进行喂狗，若在一定周期内看门狗没有收到来自软件的喂狗信号，则认为系统故障，会进入中断处理程序或强制系统复位。系统上电后根据不同的工作模式可以选择使能看门狗的时机，若看门狗被使能则计数器开始计数，如果在设定的时间内没有及时喂狗则会发生看门狗超时。 看门狗主要由寄存器、计数器和狗叫模块构成，通过寄存器对看门狗进行基本设置，计数器计算狗叫时间，狗叫模块决定看门狗超时后发出的中断或复位方式。 QOTOM Q300P自带硬件看门狗，由SuperIO芯片提供，这里简单实现一下看门狗的复位功能，只需要对看门狗的配置寄存器组和数据寄存器组进行操作。 WDTCTRL:Watch Dog Timer Control Register (Index=71h, Default=00h) 控制寄存器，主要是设置中断，这里不涉及 WDTCONF:Watch Dog Timer Configuration Register (Index=72h, Default=001s0000b) 配置寄存器 Bit6 or Bit4设置为1即可开启看门狗功能，这里使用Bit6脉冲信号 WDTVALLSB:Watch Dog Timer Time-out Value (LSB) Register (Index=73h, Default=38h) 低位数据寄存器 WDTVALMSB:Watch Dog Timer Time-out Value (MSB) Register (Index=74h, Default=00h) 高位数据寄存器 流程进入IO配置——&gt;选择逻辑设备——&gt;设置看门狗配置寄存器——&gt;设置看门狗数据寄存器（循环喂狗） 核心代码12345678910111213141516171819202122232425262728293031323334/* IO Ports */#define REG 0x2e#define VAL 0x2f/* Logical device Numbers LDN */#define LDNREG 0x07#define GPIOLND 0x07//superio enteroutb(0x87, REG);outb(0x01, REG);outb(0x55, REG);outb(0x55, REG);//select logic deviceoutb(LDNREG, REG);outb(GPIOLND, VAL);//WDT Output through KRST (pulse) Enableoutb(0x72, REG);outb(0xC0, VAL);//WDT Timer-out Value (feed dog)outb(0x73, REG);outb(0x1e, VAL);//1e:30soutb(0x74, REG);outb(0x00, VAL);//Close WDT//outb(0x72, REG);//outb(0x80, VAL);//exit superiooutb(0x02, REG);outb(0x02, VAL); 执行以上代码，如果在超时时间内没有进行喂狗，WDT将会自动产生一个复位信号，重启电脑 完整代码地址：https://github.com/huchanghui123/Watch-Dog-Linux]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>WatchDog</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Use USB Install Windows Server 2003 R2]]></title>
    <url>%2Fposts%2Fdcc09a6a%2F</url>
    <content type="text"><![CDATA[MINIPC型号：QOTOM Q100N 准备好WS2003系统镜像 cn_win_srv_2003_r2_enterprise_x64_with_sp2_vl_cd1_X13-47314.iso（系统包） cn_win_srv_2003_r2_enterprise_x64_with_sp2_vl_cd2_X13-35321.iso（补丁包） WinSetupFromUSB下载地址：http://www.winsetupfromusb.com/downloads/ 制作U盘启动器 运行WinSetupFromUSB，选择U盘 点击RMPrepUSB设置引导方式 3 BootOption栏目中选择XP/BartPE bootable[NTLDR]，在4 Filesystem and overrides中选择NTFS和Boot as HDD，然后点击6 Prepare Drive 写入引导文件，出现控制台，点击确定 完成后，窗口自动返回RMPrepUSB界面，点击exit退出 指定系统安装文件路径，先将iso装载到虚拟光驱(H:) 点击GO，开始制作 安装系统 插入U盘，BIOS设置启动项HDD第一，USB第二；开机按F11选择U盘启动 选择First part of Windows 2003 sp2 x64 … 选择需要安装系统的硬盘 然后格式化后会自动将安装程序复制到硬盘 重启后自动进入windows server安装界面 后续按提示输入就可以了 cd2 可以用ultraISO工具写入U盘，然后在windows server2003中浏览U盘安装 安装至此完成！]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux禁用CPU省电提升系统性能]]></title>
    <url>%2Fposts%2F6740782c%2F</url>
    <content type="text"><![CDATA[转载：[勤奋的小青蛙] 为了提升CPU性能，我们要禁用CPU省电状态。 我们强烈推荐禁用CPU的省电模式， 进行此更改可能会导致功耗增加，但会提高稳定性和性能。 那么：如何在Redhat或Suse Linux系统上禁用CPU节能状态？ 对于RedHat Linux（版本7及更高版本 将以下文本添加到/etc/default/grub中的GRUB_CMDLINE_LINUX行：intel_idle.max_cstate=0 processor.max_cstate=1 更新grub配置grub2-mkconfig –o /boot/grub2/grub.cfg 重启系统即可reboot 对于RedHat Linux（7之前的版本）或SuSE Linux 将以下文本添加到/boot/grub/menu.lst中的内核行：intel_idle.max_cstate=0 processor.max_cstate=1 重启生效内核参数reboot 如何在Debian Linux系统上禁用CPU省电状态? 要在Debian Linux系统上禁用CPU省电状态，请执行以下步骤： 修改/etc/default/grub中的GRUB_CMDLINE_LINUX字符串，使其包含：intel_idle.max_cstate=0 processor.max_cstate=1 更新grub配置update-grub 重启系统生效reboot]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C#获取CPU温度]]></title>
    <url>%2Fposts%2Fcd4df5e5%2F</url>
    <content type="text"><![CDATA[开发环境QOTOM工控电脑，Visual Studio 2017，OpenHardwareMonitor开源库 OpenHardwareMonitor: https://github.com/openhardwaremonitor/openhardwaremonitor 新建项目OpenHardwareMonitor源代码中有两个程序集：OpenHardwareMonitor和OpenHardwareMonitorLib OpenHardwareMonitor是一个winform程序，OpenHardwareMonitorLib是一个类库，运行时生成OpenHardwareMonitorLib.DLL这个动态链接库，而我们要实现CPU温度信息的获取，就是要引用这个DLL OpenHardwareMonitor界面如下图： OpenHardwareMonitor能获取的传感器还是很多的，因为本人也不是很了解这个库，这里只简单介绍下如何获取CPU温度 本地新建一个WinFrom项目，将生成的OpenHardwareMonitorLib.dll拷贝到新建项目的debug目录下 右键项目添加引用，浏览指定的dll文件 然后引用OpenHardwareMonitor.Hardware这个命名空间，继承IVisitor这个接口 1234567891011121314151617181920using OpenHardwareMonitor.Hardware;public class UpdateVisitor : IVisitor&#123;public void VisitComputer(IComputer computer)&#123;computer.Traverse(this);&#125;public void VisitHardware(IHardware hardware)&#123;hardware.Update();foreach (IHardware subHardware in hardware.SubHardware)subHardware.Accept(this);&#125;public void VisitSensor(ISensor sensor) &#123; &#125;public void VisitParameter(IParameter parameter) &#123; &#125;&#125; 接下来要实例化我们访问的对象，这里命名为myComputer，通过myComputer这个对象的一些属性，我们可以得到我们需要获取的信息 12345Computer myComputer = new Computer();UpdateVisitor updateVisitor = new UpdateVisitor();myComputer.Open();myComputer.CPUEnabled = true;myComputer.Accept(updateVisitor); 获取CPU温度代码 1234567891011121314151617181920212223242526272829303132333435class Program &#123; static int GetTemperature() &#123; int ret = 0; Computer myComputer = new Computer(); UpdateVisitor updateVisitor = new UpdateVisitor(); myComputer.Open(); myComputer.CPUEnabled = true; myComputer.Accept(updateVisitor); foreach (var hardwareItem in myComputer.Hardware) &#123; if (hardwareItem.HardwareType == HardwareType.CPU) &#123; foreach (var sensor in hardwareItem.Sensors) &#123; //温度 if (sensor.SensorType == SensorType.Temperature) &#123; //ret = Convert.ToInt32(sensor.Value); Console.WriteLine(&quot;NAME:&quot; + sensor.Name + &quot; Value:&quot; + sensor.Value + &quot;°C MIN:&quot; + sensor.Min + &quot;°C Max:&quot; + sensor.Max + &quot;°C&quot;); &#125; &#125; &#125; &#125; myComputer.Close(); return ret; &#125; static void Main(string[] args) &#123; GetTemperature(); Console.ReadKey(); &#125; OpenHardwareMonitorLib需要使用管理员权限才能调用，将程序设置位默认管理员权限执行，右键项目——添加新项——应用程序清单文件，将level=”asInvoker”修改为level=”requireAdministrator” 1&lt;requestedExecutionLevel level=&quot;requireAdministrator&quot; uiAccess=&quot;false&quot; /&gt; 运行结果，这里只调用了一次，可以做成多线程，500毫秒读一次 项目地址：https://github.com/huchanghui123/Read-PC-hardware-info.git]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>C#</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Clonezilla备份还原系统]]></title>
    <url>%2Fposts%2F3390c071%2F</url>
    <content type="text"><![CDATA[Clonezilla Download 制作USB启动盘 第一种方法（未测试） 下载ISO镜像，使用UltraISO写入镜像 第二种方法（未测试） 下载USB类型zip包 USB格式化为FAT32，至少200MB 解压zip到U盘根目录 以管理员身份执行 F:\utils\win32\makeboot.bat（makeboot.bat必须在U盘上执行） 第三种方法 使用tuxboot工具 下载地址：http://tuxboot.nchc.org.tw/ 备份系统到U盘 从U盘启动，选择Clonezilla live (default settings)，进入再生龙 在使用语言菜单中选择“zh_CN.UTF-8Chinese(Simplified)|简体中文” 处理键盘映射的策略，选择“不修改键盘映射” 选定模式菜单，选择“使用再生龙 选定备份/恢复的模式，选择“device-image硬盘/分区[存到/来自]镜像文件” 挂载再生龙镜像文件的目录，选择模式“local_dev使用本机的分区（如：硬盘，随身盘） 注意：如果要将备份的镜像存储到再生龙工具U盘或是准备恢复的镜像存储在再生龙工具U盘中，请选择“Skip 使用现有的/home/partimage（可写装置如硬盘/随身盘）” 此时再生龙会提示如果你的镜像存储盘是U盘，请将U盘连接到主板上并且等待5秒钟后按回车键，再生龙会挂载U盘如果存储镜像的存储盘是已经连接到主板上的硬盘，可以直接按回车键 选择镜像存放或读取镜像的设备，此时要清楚存储盘的盘符，我这里是/dev/sdc 在该存储盘的设备中选择镜像存放或读取的具体目录，一般选择根目录“/”，我的盘是空盘，没有显示，选择“初学者模式” 选择备份/恢复的模式，这里菜单中有两种模式 “savedisk 存储本机硬盘为镜像文件”，此模式是将目标盘进行整盘备份 “saveparts 存储本机分区为镜像文件”，此模式是对目标盘的某个分区进行备份 再生龙整盘备份功能：选择“savedisk”后，输入一个名称来存放所要备份硬盘的镜像文件 选择要备份的磁盘 我备份的系统是Windows，跳过检查 检查镜像是否能被还原，不对镜像加密 按提示操作，按y继续 备份系统中… 备份完成，按Enter键进行关机或重启 还原系统到硬盘 插入保存有再生龙镜像的USB，系统会检测到Clonezilla映像，按TAB键选择DONE，按ENTER键继续 选择初学者模式 选择“restoredisk”后，再生龙会自动列出存储盘的整盘镜像文件 选取所需要的镜像文件 接下来选择目的硬盘准备进行恢复，按回车键继续，然后按两次y进行还原 还原系统中… 还原完成后选择关机或重启 至此结束!]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Clonezilla</tag>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[向WIN7 USB安装盘中添加USB3.0驱动]]></title>
    <url>%2Fposts%2F3911%2F</url>
    <content type="text"><![CDATA[WIN7原版映像中添加USB3.0驱动程序​ 最新发现用rufus制作的原版win7 USB启动盘，在某些板子上安装系统时，无法识别到键盘鼠标，导致无法进行安装，百度了一下发现是原版的win7镜像没有集成USB3.0的驱动，然后如今的电脑主板基本是XHCI主控（以前是EHCI的），这一变动导致在安装Win7的过程中会出现USB接口失灵的状况，所以在安装时无法识别键盘、鼠标、U盘。这样我们就只能在映像文件中添加usb3.0驱动了。 百度后发现实现方法不少 使用UltraISO提取出镜像的boot.wim，install.wim，然后打开powershell，用dism命令将驱动合入wim映像 使用dism++程序为映像添加驱动 使用intel官方工具win7-usb3.0-creator添加驱动（官网已下架） 使用技嘉WindowsImageTool（感觉最好用） 这里只介绍第四种，前面的方法请自行百度. 使用WindowsImageTool添加USB3.0驱动 先下载工具：https://www.gigabyte.cn/Motherboard/GA-Z170X-Gaming-G1-rev-10#utility 制作WIN7 USB启动盘 使用管理员权限启动WindowsImageTool.exe，选择制作号的USB启动盘 点击start开始制作，大概7分半钟制作完成 重新将U盘插入主板开机选择USB，进入WIN7安装界面后鼠标能够正常移动，安装过程完美。]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[金蝶K/3 Wise v14.0安装配置]]></title>
    <url>%2Fposts%2F22963%2F</url>
    <content type="text"><![CDATA[主机：QOTOM Q300P 系统：Windows Server 2008 R2 安装环境检测 金蝶K3安装之前必须先进行环境检测，满足环境所需的组件后才能进行安装，否则会使用不了，打开资源包进行环境检测 例，环境检测需要安装SQL Server数据库 SQLServer 2008R2下载地址：https://msdn.itellyou.cn/ 安装略过… 环境检测会提示缺少的组件，点击确定会自动进行安装，期间会提示安装很多程序或组件 资源包的环境检测程序，有部分程序无法自动安装，比如IIS，需要自行安装配置 Windows Server 2008中间层环境配置 打开服务器管理，点击操作，添加角色，勾选IIS、应用程序服务器 应用程序服务器角色服务配置，服务器验证选择了自签名证书 WEB服务器角色服务配置 勾选好需要的功能后确认安装 安装中… 安装完成 客户端、中间层服务部件有个系统更新安装不上，这里暂时未找到解决办法 Windows Server 2008 WEB 服务器环境配置WEB服务器配置先配置完中间层，再额外配置如下环境即可。 WEB服务器适用于需要用到CRM，HR，客户门户，供应商协同系统的使用者，如果不需要使用上述系统，则WEB服务器配置可省略。 首先正常安装好IIS服务，再按以下方式进行配置。 进入IIS配置界面 启用父路径设置为True 设置支持IIS运行的.Net Framework版本为2.0(默认) 修改IIS服务工作模式，IIS应用程序池默认是集成模式，参照如下步骤进行安装，设置K/3的虚拟目录应用程序池为经典模式 WEB服务器配置完成后，即可通过K/3的安装包安装WEB服务端 金蝶K/3 WISE 安装 打开金蝶安装文件包，打开安装程序 自定义安装所有或者部分中间层组件，根据需要自行勾选 安装过程比较漫长，后面会安装很多组件和工具… 中间层组件安装（程序——金蝶K3——金蝶K3服务器配置工具——中间层组件注册） 运行 “程序——金蝶K3——金蝶K3服务器配置工具——账套管理” 新建或恢复、注册账套 WEB系统配置工具，根据需要自行勾选，点击完成（程序——金蝶K3——金蝶K3服务器配置工具——站点及远程组件配置工具） 主程序安装完成 客户端安装不会弹窗，运行 “程序——金蝶K3——金蝶K3工具——远程组件配置工具” 完成远程组件注册和配置 问题解决 无法新建数据库 在K3安装目录下找到DBFILE文件夹，右键属性——安全——高级——更改权限——添加everyone用户并赋予“完全控制权”，修改后创建成功 控制面板无法卸载干净K3 每个版本安装后，会在C:\Program Files (x86)\InstallShield Installation Information生成一个GUID编码，删除这个文件夹即可删除K3的安装信息 删除注册表，找到\HKEY_LOCAL_MACHINE\SOFTWARE\KINGDEE\KDPRODUCT删除 删除K3安装目录 清除注册信息，进入安装包中的other目录，运行RegClear.exe，勾选清除远程注册信息]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Mini Pc</tag>
        <tag>K3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QOTOM Install SQLServer 2008R2]]></title>
    <url>%2Fposts%2F50337%2F</url>
    <content type="text"><![CDATA[准备安装环境系统环境：Windows Server 2008R2 x64 8GDDR3 60G SSD CPU:I5 SQLServer 2008R2下载地址：https://msdn.itellyou.cn/ 安装过程 双击下载好的安装文件setup.exe (需要.NET Framework 3.5 SP1，系统会自行安装) ，点击确定 弹出sql server安装中心界面，点击左侧栏目“安装” 点击右边栏目的“全新安装或向现有安装添加功能” “安装程序正在处理当前操作，请稍后”等一会，下面安装过程中很多次都弹出sql server安装中心主界面可以不用管 然后会弹出一个会话框“安装程序支持规则”，检查正常，点击确定 选择输入产品密钥（默认），并输入密钥，点击下一步 勾选：我接受许可条款，并点击下一步 点击安装 检测出现防火墙警告，关闭防火墙重新运行即可，然后下一步 选中SQL Server 功能安装（默认），并点击下一步 功能选择：点击全选按钮，（共享功能目录看个人意愿是否需要修改到其他盘） 点击下一步 实例配置，使用系统默认 点击下一步 服务器配置：点击对所有SqlServer服务使用相同的账户，使用第一个（NT AUTHORITY\NEWORK SERVICE），不用输密码，点击确定 数据库引擎配置：这里附张图（密码自己输入，左下角点击添加用户后，稍等一下，可能需要一两秒，之后下一步就行） Analysis Services配置 （也是添加当前用户，下一步） Reporting Services配置，直接下一步 错误报告，直接下一步 安装配置规则，下一步 点击安装 安装中…(这里要等一会，十几分钟) 安装完成，点击关闭 使用数据库 在Windows开始菜单中，打开数据库管理工具，连接 新建数据库就可以使用了]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>SQLServer</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QOTOM Install Windows Server 2008 r2 Datacenter]]></title>
    <url>%2Fposts%2F4175%2F</url>
    <content type="text"><![CDATA[环境硬件：QOTOM Q350P I5-4308U 8G ddr3 系统镜像：cn_windows_server_2008_r2_standard_enterprise_datacenter_web_x64_dvd_x15_50360.iso 启动盘Rufus制作启动盘，选项全部默认 将U盘插入电脑，看到主板开机Logo后按F11，选择U盘启动，安装过程没啥好讲的，一直next就行 驱动安装系统安装完成后，检查设备管理，PCI，SMB，USB，网卡驱动没有安装 Q300P 主板使用intel i211网卡，WS2008默认不支持，需要手动安装网卡驱动 intel官网下载ws2008的网卡驱动，地址：https://downloadcenter.intel.com/zh-cn/download/18725 安装下载的程序PROWinx64Legacy.exe 打开设备管理器，找到网卡，右键更新驱动——&gt;选择浏览计算机——&gt;从计算机选择——&gt;网络适配器 厂商intel，选择型号I210 Gigabit Network，下一步无视警告安装 安装后网络就可正常使用了。 pci驱动win10_64位驱动：intel_mei_1176_64_216.exe SM总线win10_64位驱动：intel_smbus_10027_64_1228.exe USB3.0Win7_64位驱动：intel_usb30_25440.exe 以上驱动安装完成即可消除所有黄色感叹号]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Mini PC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Red Hat更换Centos6源]]></title>
    <url>%2Fposts%2F52372%2F</url>
    <content type="text"><![CDATA[RedHat使用自带的yum源是需要注册的，不想注册的可以替换本地源使用 工控机型号： QOTOM 190G4-M 系统： Red Hat Enterprise Linux Server release 6.7 (Santiago) x86_64 Red Hat Enterprise Linux ISO 镜像下载： https://wanghualang.pipipan.com/dir/13133650-26232498-a8efb3/ 软件包下载地址： x86 地址：http://mirrors.163.com/centos/6/os/i386/Packages/ x86_64 地址：http://mirrors.163.com/centos/6/os/x86_64/Packages/ 替换centos6源 卸载yum源 1rpm -qa|grep yum|xargs rpm -e --nodeps 安装yum软件包 12345rpm -ivh python-iniparse-0.3.1-2.1.el6.noarch.rpmrpm -ivh yum-metadata-parser-1.1.2-16.el6.x86_64.rpmrpm -ivh yum-3.2.29-40.el6.centos.noarch.rpm yum-plugin-fastestmirror-1.1.30-14.el6.noarch.rpm 更改yum源 编辑CentOS6-Base-163.repo文件，存放到/etc/yum.repo.d 12345678910111213141516171819202122232425262728293031323334353637383940[base]name=CentOS-6 - Base - 163.combaseurl=http://mirrors.163.com/centos/6/os/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=6$releasever&amp;arch=$basearch&amp;repo=osgpgcheck=1gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#released updates [updates]name=CentOS-6 - Updates - 163.combaseurl=http://mirrors.163.com/centos/6/updates/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=6$releasever&amp;arch=$basearch&amp;repo=updatesgpgcheck=1gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#additional packages that may be useful[extras]name=CentOS-6 - Extras - 163.combaseurl=http://mirrors.163.com/centos/6/extras/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=6$releasever&amp;arch=$basearch&amp;repo=extrasgpgcheck=1gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#additional packages that extend functionality of existing packages[centosplus]name=CentOS-6 - Plus - 163.combaseurl=http://mirrors.163.com/centos/6/centosplus/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=6$releasever&amp;arch=$basearch&amp;repo=centosplusgpgcheck=1enabled=0gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6#contrib - packages by Centos Users[contrib]name=CentOS-6 - Contrib - 163.combaseurl=http://mirrors.163.com/centos/6/contrib/$basearch/#mirrorlist=http://mirrorlist.centos.org/?release=6$releasever&amp;arch=$basearch&amp;repo=contribgpgcheck=1enabled=0gpgkey=http://mirror.centos.org/centos/RPM-GPG-KEY-CentOS-6 清除缓存文件及目录 1yum clean all 获取yum列表 1yum makecache 图形界面安装 查看当前系统运行级别 1runlevel 查看桌面环境的组件 1yum grouplist|more 安装GNOME图形界面 12yum groupinstall “X Window System” -yyum groupinstall “Desktop” -y 安装成功后输入startx，或者init 5, 即可切换到图形界面（临时生效）修改/etc/inittab文件中的id:3:initdefault将3改为5（永久生效） 卸载图形化界面利用组卸载命令 yum groupremove + 组包名即可，其中组包名就是我们之前上面安装的。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Red Hat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pfsense设置系统重启任务]]></title>
    <url>%2Fposts%2F49274%2F</url>
    <content type="text"><![CDATA[Pfsense本身没有自动重启系统的选项，需要通过pfsense的计划任务实现系统重启 进入pfsense GUI中，转到System &gt; Package Manager 单击Available Packages 并搜索cron 单击install，安装cron插件。安装完成后，进入Services &gt; cron配置页面 单击 底部的Add按钮来添加新的计划任务，下图为每天5：30重启系统]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>Pfsense</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04配置serial console]]></title>
    <url>%2Fposts%2F38655%2F</url>
    <content type="text"><![CDATA[Ubuntu串口控制台登录电脑硬件：QOTOM Q300P[ubuntu]，Q600P[windows10] Windows串口使用COM4 Ubuntu串口使用第一个/dev/ttyS0，115200 baud 8n1 配置Grub 编辑/etc/default/grub并添加以下代码： 123GRUB_CMDLINE_LINUX=&quot;console=tty0 console=ttyS0,115200n8&quot;GRUB_TERMINAL=serialGRUB_SERIAL_COMMAND=&quot;serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1&quot; 修改完成后的代码： 12345678910111213141516171819...GRUB_DEFAULT=0#GRUB_TIMEOUT_STYLE=hiddenGRUB_TIMEOUT=5GRUB_DISTRIBUTOR=`lsb_release -i -s 2&gt; /dev/null || echo Debian`#GRUB_CMDLINE_LINUX_DEFAULT=&quot;quiet splash&quot;GRUB_CMDLINE_LINUX_DEFAULT=&quot;&quot;GRUB_CMDLINE_LINUX=&quot;console=tty0 console=ttyS0,115200n8&quot;# Uncomment to enable BadRAM filtering, modify to suit your needs# This works with Linux (no patch required) and with any kernel that obtains# the memory map information from GRUB (GNU Mach, kernel of FreeBSD ...)#GRUB_BADRAM=&quot;0x01234567,0xfefefefe,0x89abcdef,0xefefefef&quot;# Uncomment to disable graphical terminal (grub-pc only)#GRUB_TERMINAL=consoleGRUB_TERMINAL=serialGRUB_SERIAL_COMMAND=&quot;serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1&quot;... 更新grub 1sudo update-grub 修改ttyS0配置文件 添加ttyS0配置 1root@ubuntu:/# vim /etc/init/ttyS0.conf 添加如下代码： 12345678910# ttyS0 - getty## This service maintains a getty on ttyS0 from the point the system is# started until it is shut down again.start on stopped rc RUNLEVEL=[2345]stop on runlevel [!2345]respawnexec /sbin/getty -L 115200 ttyS0 vt100 WIN10测试结果使用putty进行串口连接成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win10 Remote Ubuntu18.04]]></title>
    <url>%2Fposts%2F17898%2F</url>
    <content type="text"><![CDATA[Ubuntu设置系统版本：Ubuntu 18.04.2 LTS 打开设置，修改sharing选项如下： 安装xrdp，终端输入：sudo apt-get install xrdp 终端输入：sudo vim /etc/xrdp/startwm.sh，注释最后两行，并添加gnome-session修改如下： 123#test -x /etc/X11/Xsession &amp;&amp; exec /etc/X11/Xsession#exec /bin/sh /etc/X11/Xsessiongnome-session 重新启动ubuntu，不要登录 Windows进行远程连接 打开CMD窗口，输入mstsc，打开windows的远程桌面连接，输入Ubuntu的IP地址，并点击连接 点击连接之后会进入登录页面，选择Xorg，输入用户名，并填写在Sharing中设置的密码，即可登录 首次登录会提示几次授权修改主机的颜色设置什么的，都可以cancel掉，然后即可登陆成功 问题：windows关闭远程后，ubuntu也不能登陆，原因是远程桌面没有正确关闭，虽然在windows 系统关闭远程桌面连接，但是在里linux上的进程还在运行 解决：修改/etc/xrdp/sesman.ini参数KillDisconnected=true，断开连接60s后linux会关闭会话进程 重启/etc/init.d/xrdp restart 问题解决 参考：https://zhuanlan.zhihu.com/p/40937988]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt X86 分区扩容]]></title>
    <url>%2Fposts%2F3221e6f0%2F</url>
    <content type="text"><![CDATA[硬件情况：K500G6 X86工控路由电脑、4G内存、16G金士顿SSD 固件版本：git clone https://github.com/openwrt/openwrt.git 自己编译（Linux OpenWrt 4.14.63 ） 安装方式：Ubuntu编译固件完成后执行dd if=openwrt-x86-generic-combined-ext4.img of=/dev/sdb 查看磁盘分配情况ssh打开openwrt控制台，查看系统只用了两百多M，太浪费SSD了，如果长时间安装软件后面空间肯定会不够用。 1234567root@OpenWrt:/# df -hFilesystem Size Used Available Use% Mounted on/dev/root 252.0M 13.8M 233.0M 6% /tmpfs 1.9G 1.1M 1.9G 0% /tmp/dev/sda1 15.7M 4.5M 10.9M 29% /boot/dev/sda1 15.7M 4.5M 10.9M 29% /boottmpfs 512.0K 0 512.0K 0% /dev 使用fdisk -l发现找不到命令，这里需要手动安装下 1opkg install fdisk 安装后执行fdisk -l查看空间分配情况 1234567891011root@OpenWrt:/# fdisk -lDisk /dev/sda: 14.9 GiB, 16013942784 bytes, 31277232 sectorsUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x6ad5f5a9Device Boot Start End Sectors Size Id Type/dev/sda1 * 512 33279 32768 16M 83 Linux/dev/sda2 33792 558079 524288 256M 83 Linux 对空闲空间进行分区openwrt的fdisk貌似没有分区功能，没有fdisk -n命令，查找资料后发现可以使用cfdisk工具进行分区，cfdisk是一个基于curses的程序，用于分区任何硬盘驱动器 1opkg install cfdisk 对空闲空间进行分区，默认分区类型为Linux 选择Free space——&gt;primary——&gt;Write——&gt;yes fdisk -l查看已经分好区了 1234Device Boot Start End Sectors Size Id Type/dev/sda1 * 512 33279 32768 16M 83 Linux/dev/sda2 33792 558079 524288 256M 83 Linux/dev/sda3 559104 31277231 30718128 14.7G 83 Linux 先对分区进行格式化，然后进行挂载 1234567891011mkfs.ext4 /dev/sda3mkdir optmount -o rw /dev/sda3 opt/root@OpenWrt:/# df -hFilesystem Size Used Available Use% Mounted on/dev/root 252.0M 14.2M 232.7M 6% /tmpfs 1.9G 1.1M 1.9G 0% /tmp/dev/sda1 15.7M 4.5M 10.9M 29% /boot/dev/sda1 15.7M 4.5M 10.9M 29% /boottmpfs 512.0K 0 512.0K 0% /dev/dev/sda3 14.4G 40.0M 13.6G 0% /opt 调整安装目录安装目录在配置文件/etc/opkg.conf中定义。配置文件中目的地址格式是以dest开头，紧跟着目的地址的名称，最后是目录路径，必须从跟目录开始。 123dest root /dest ram /tmpdest soft /opt 安装目录定义后，目的地址名称就可以在安装命令中引用了。例如“-d ram”表示将软件安装到临时目录/tmp下。 安装命令类似如下格式： opkg install -d &lt;目的地址&gt; 例如： 先卸载之前安装的fdisk，opkg remove fdisk 重新安装到opt目录，opkg install fdisk -d soft 安装完成后，如果执行fdisk，并不会找到该命令，还需要设置环境变量PATH，编译配置文件/etc/profile 12export PATH=&quot;/usr/sbin:/usr/bin:/sbin:/bin:/opt/bin:/opt/sbin:/opt/usr/sbin:/opt/usr/bin&quot;export LD_LIBRARY_PATH=/opt/lib:/opt/usr/lib 修改后使用正常 123456789101112131415root@OpenWrt:/# ls /opt/usr/sbin/fdisk hostapdroot@OpenWrt:/# fdisk -lDisk /dev/sda: 14.94 GiB, 16013942784 bytes, 31277232 sectorsDisk model: KINGSTON RBU-SMSUnits: sectors of 1 * 512 = 512 bytesSector size (logical/physical): 512 bytes / 512 bytesI/O size (minimum/optimal): 512 bytes / 512 bytesDisklabel type: dosDisk identifier: 0x7fd3e4c3Device Boot Start End Sectors Size Id Type/dev/sda1 * 512 33279 32768 16M 83 Linux/dev/sda2 33792 295935 262144 128M 83 Linux/dev/sda3 296960 31277231 30980272 14.8G 83 Linux 有些软件安装包会在Init.d生成启动脚本，比如openvpn，这时就需要创建一个启动软连接，例如： 1ln -s /opt/etc/init.d/openvpn /etc/init.d/openvpn ​ 许多软件包在自定义的位置不能启动或者即使启动也不能成功执行，因为它在默认位置读取配置文件，因此需要在参数中制定配置文件位置，否则会因不能找到必须的配置文件而出错；还有些软件包在更改了目录后需要额外的软连接或者修改动态链接库文件名后缀才能使用，并且Luci配置页面只会显示安装在根目录的软件包，希望后面可以优化，将指定的安装目录加入空闲空间。]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Read CPU Type and Temperature]]></title>
    <url>%2Fposts%2F3b1098bd%2F</url>
    <content type="text"><![CDATA[​ 前段时间利用Superio获取到了CPU风扇速度，并且利用Superio读取到了CPU的温度(Intel PCIE)，但通过sensors命令对比，发现封装的CPU温度和核心温度有误差，于是想通过代码获取下温度，来测试下是否正确。在网上查找了很多资料，这里记录一下成果。 获取Intel CPU 信息和温度CPU信息可以通过cpuid指令获取，在用户空间可以通过内嵌汇编代码实现，代码如下： 12345678910111213141516171819202122struct cpuid_res &#123; uint32_t eax; uint32_t ebx; uint32_t ecx; uint32_t edx;&#125;;static inline struct cpuid_res cpuid(int op)&#123; struct cpuid_res result; asm volatile( &quot;mov %%ebx, %%edi;&quot; &quot;cpuid;&quot; &quot;mov %%ebx, %%esi;&quot; &quot;mov %%edi, %%ebx;&quot; : &quot;=a&quot; (result.eax), &quot;=S&quot; (result.ebx), &quot;=c&quot; (result.ecx), &quot;=d&quot; (result.edx) : &quot;0&quot; (op) : &quot;edi&quot;); return result;&#125; 获取厂家名称以eax=0 执行 cpuid，eax为0表示读取vendor id，一共12字节，依次在ebx、edx、ecx。 12345result = cpuid(0);vendor_name[0] = (result.ebx &gt;&gt; 0) &amp; 0xff;vendor_name[1] = (result.ebx &gt;&gt; 8) &amp; 0xff;...vendor_name[11] = (result.ecx &gt;&gt; 24) &amp; 0xff; 获取芯片型号用cpuid指令，eax传入分别0x80000002/0x80000003/0x80000004，读取cpu型号，每个4个寄存器，每个寄存器4字节，一共48字节。 12345678910struct cpuid_res res;char processor_name[49];unsigned int *cpu_type = (unsigned int *)processor_name;for (int i = 0; i &lt; 3; i++) &#123; res = cpuid(0x80000002 + i); cpu_type[i * 4 + 0] = res.eax; cpu_type[i * 4 + 1] = res.ebx; cpu_type[i * 4 + 2] = res.ecx; cpu_type[i * 4 + 3] = res.edx; &#125; 获取CPU温度Intel和AMD的CPU中都有温度传感器（DTS），每个核心都有一个，温度就是由此获取来的。Intel对CPU温度的处理，设置了一个最高温度Tjunction，从MSR中读取的数据为与最高温度的温差Delta，并非实际温度，实际温度为Tjunction-Delta。 检查CPU是否支持DTS先以eax=0 执行 cpuid 检测 eax 支持的最大命令数，如果小于6就肯定不支持DTS。 1int level = cpuid(0).eax; 以eax=6 执行 cpuid, 然后测试 eax 第一位是否为1，如果为1表示CPU支持DTS。 12int val = cpuid(6).eax;char dts = (val&gt;&gt;0)&amp;0x01; 读取DTS要获取cpu的温度可以通过汇编指令来读取。但linux环境下，msr指令必须要在内核层才能调用，这里我在驱动中中实现ioctl接口，然后返回数据给用户层。 123456uint32_t lo, hi;asm volatile( &quot;rdmsr&quot; : &quot;=a&quot; (lo), &quot;=d&quot; (hi) : &quot;c&quot; (op) ); Tjunction：当核心温度达到了阀值，会通过降频、降压、风扇调节等形式调节温度。 以 ecx=0x1A2 执行 rdmsr 指令，通过0x1A2来读取MSR的[16-22]位得到Tjunction。 1u64 __val = __rdmsr(0x1A2);//&lt;asm/msr.h&gt; Delta：我们从MSR读到的温度是距离Tjunction的温差，而不是实际温度 以 ecx=0x19C 执行 rdmsr 指令，通过0x19C来读取MSR的[16-22]位得到Delta。 1u64 __val2 = __rdmsr(0x19C); 当前cpu温度 = Tjunction - Delta 核心代码： 12345678910111213141516u64 __val = __rdmsr(0x1A2);printk(&quot;__val is %016llx\n&quot;,__val);u64 __val2 = __rdmsr(0x19C);printk(&quot;__val2 is %016llx\n&quot;,__val2);u8 tjunction,delta,coretemp;tjunction = (__val&gt;&gt;16)&amp;0x7f;delta = (__val2&gt;&gt;16)&amp;0x7f;coretemp = tjunction - delta;printk(&quot;tjunction is %.1d°C ;delta is %.1d°C;core temp is %.1d°C\n&quot;, tjunction, delta, coretemp);char buf_temp[30] = &quot;CPU温度:&quot;;char core_temp[4];sprintf(core_temp, &quot;%d&quot;, coretemp);strcat(buf_temp,core_temp);copy_to_user((char __user *)arg, buf_temp, strlen(buf_temp)); 通过对比sensors，这里获取的是Core 1的温度，Core 0的温度可以通过切换核心读取到。 代码地址：https://github.com/huchanghui123/my_cdev/blob/master/my_dev.c]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux Superio Read CPU FAN RPM]]></title>
    <url>%2Fposts%2F5c7fdca%2F</url>
    <content type="text"><![CDATA[​ 之前写了一篇Linux下利用Superio控制GPIO的教程，这次继续利用Superio读取CPU风扇转速，CPU风扇属于环境控制器（EC），内置在IT8786E-I中，包括五个电压输入，三个温度传感器输入，五个FAN转速计输入和五组先进的风扇控制器。 EC监控硬件环境，实现个人电脑的环境控制。 大致流程 进入MB PnP 模式（87h, 01h, 55h, 55h;） 使能 EC（LDN=04h, Index 30h=01） 得到EC Base Address 基地址由逻辑设备寄存器确定（index=60h, 61h） 数据端口（Base+05h）；数据端口（Base+06h） 配置风扇转速寄存器（index=0Ch，default=00h） 计算出风扇转速（index=0Dh,18h） 退出MB PnP 模式（index=02h，default=02h） LInux实现代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384#include&lt;stdio.h&gt;#include&lt;sys/io.h&gt;#include&lt;unistd.h&gt;#include&lt;math.h&gt;#define REG 0x2e#define VAL 0x2f#define CHIPID 0x20#define CHIPREV 0x22static int superio_inw(int reg)&#123; int val; outb(reg++, REG); val = inb(VAL) &lt;&lt; 8; outb(reg, REG); val |= inb(VAL); return val;&#125;static void init_ec()&#123; //Enter MB PnP Mode outb(0x87, REG); outb(0x01, REG); outb(0x55, REG); outb(0x55, REG); //使能EC控制器 outb(0x07, REG); outb(0x04, VAL); outb(0x30,REG); outb(0x01,VAL);&#125;int main()&#123; unsigned int ec_base,addr_port,data_port,fan_speed,fan_rpm; int ret = iopl(3); if(ret == -1) &#123; printf(&quot;iopl error.\n&quot;); return -1; &#125; //初始化 init_ec(); //获取EC控制器基地址 ec_base = superio_inw(0x60); printf(&quot;ec_base addr:0x%x\n&quot;, ec_base); addr_port = ec_base+0x05; data_port = ec_base+0x06; printf(&quot;addr_port is 0x%x data_port is 0x%x\n&quot;,addr_port,data_port); //配置风扇转速计控制寄存器 outb(0x0c, addr_port); outb(0x00, data_port); //一起有三组，这里使用的第一组，也就是CPU_FAN //1:CPU_FAN 2:SYS_FAN 3:PWR_FAN //1-3 Reading Registers[7:0] (Index=0Dh-0Fh) outb(0x0d,addr_port); int lval = inb(data_port); //1-3 Extended Reading Registers [15:8] (Index=18h-1Ah) outb(0x18,addr_port); int mval = inb(data_port); //每转的内部时钟计数，这里是16位 fan_speed = (mval&lt;&lt;8) | lval; printf(&quot;mval:%02x lval:%02x fan_speed is %d\n&quot;,mval, lval, fan_speed); //最后根据芯片手册的公式计算出风扇转速 fan_rpm = 1.35*pow(10,6)/(fan_speed*2); printf(&quot;fan_rpm is %d\n&quot;,fan_rpm); //读取tmp1温度寄存器 outb(0x29, addr_port); float tmpin1 = inb(data_port); printf(&quot;tmpin1 is %.1f °C\n&quot;,tmpin1); //Exit MB PnP Mode outb(0x02, REG); outb(0x02, VAL); iopl(0); return 0;&#125; 代码执行结果 项目地址：https://github.com/huchanghui123/IT87-SUPERIO-FAN.git]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
        <tag>SuperIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[X86 Linux ITE SuperIO GPIO Control]]></title>
    <url>%2Fposts%2F511726ae%2F</url>
    <content type="text"><![CDATA[Superio概述​ Super I/O芯片也叫I/O芯片。在486以上档次的主板上都有I/O控制电路。因为在南桥这样的高速设备和串行、并行接口、软盘驱动器及键盘鼠标等大量低速设备之间必定存在资源的不匹配，而需要经过转换和管理。而Super I/O芯片则完成了该功能。 ​ 通常在硬件监控芯片硬件监控芯片中会整合超级I/O功能，可用于监控受监控对象的电压、温度、转速等。主板在附件中会提供某种软件，它和主板上的硬件配合使用就能实现对电压、温度、风扇转速等的监控，一旦检测到这些参数超出设定的指标时，它会自动作出调整，以保护元件的安全。 以上内容均为copy自互联网。 使用的SIO为ITE的IT8786E，预留的GPIO端口为GP80~GP87 IT8786芯片在主板的实物图如下： 本人对SuperIO也不懂，主要是参考linux内核中gpio-it87驱动代码和github上的其他项目摸索出来的，文中可能会有一些错误！ 大概的流程：以下的数据都来源于芯片手册： SuperIO控制器地址端口index=2Eh，数据端口index=2Fh(实际的物理内存地址)； SuperIO芯片功能入口：87h,01h,55h,55h； GPIO LDN逻辑设备号：07h； GP80-GP87：寄存器地址index=2Ch，Default=89h； GPIO Output/Input Selection： index=CFh； GPIO Simple I/O Base Address MSB/LSB Register：Index=62h/63h, Default=00h； 进入IO配置空间 设置IO属性 设置输入输出模式 当IO输出时设置高低电平 退出IO配置空间 实现代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869#include&lt;stdio.h&gt;#include&lt;sys/io.h&gt;#include&lt;stdlib.h&gt;/* IO Ports */#define REG 0x2e#define VAL 0x2f/* Logical device Numbers */#define LDNREG 0x07/* GPIO Configuration Registers */#define GPIOLDN 0x07static int superio_inw(int reg)&#123; int val; outb(reg++, REG); val = inb(VAL) &lt;&lt; 8; outb(reg, REG); val |= inb(VAL); return val;&#125;int main(void)&#123; unsigned short int io_base; //修改端口权限为可读写 int ret = iopl(3); if(ret == -1) &#123; printf(&quot;iopl error.\n&quot;); return -1; &#125; //进入IO配置空间 outb(0x87, REG); outb(0x01, REG); outb(0x55, REG); outb(0x55, REG); //设置IO属性 outb(LDNREG, REG); outb(GPIOLDN, VAL); //Speecial Function Selection Register3(Index=2Ch, Default=89h) outb(0x2c, REG); outb(0x89, VAL); //Simple I/O Base Address MSB/LSB Register index=62h/63h //获取GPIO基地址(16位),高位0x62|低位0x63组合起来 io_base = superio_inw(0x62); printf(&quot;gpio base addr:%02x\n&quot;, io_base); //设置输入输出模式Output/Input Selection (Index CFh） //0xcf 控制GP80~87 作为输入还是输出 outb(0xcf, REG); //bit0对应GP80,bit1对应GP81,以此类推。以下是把所有IO作为输出 outb(0xff, VAL); //当IO作为输出时，拉高、或拉低设置 //使用的第8组GPIO，这里地址是基地址+7 //控制GP80~87输出高还是低,相应的BIT 设为0拉低，设为1拉高 //bit0对应GP80,bit1对应GP81,以此类推。这里所有IO设置为高电平 outb(0xff,io_base+7); //设置完后退出IO配置空间 outb(0x02, REG); outb(0x02, VAL); //恢复端口权限 iopl(0); return 0;&#125; 编译后执行需要root权限，可以直接上LED测试，下图接线是低电平点亮 另外还实现了一种方法，直接写成驱动的方式，创建一个misc设备，实现ioctl函数，利用ioctl通信在用户空间操作GPIO，这里就不贴代码了 项目源代码：https://github.com/huchanghui123/ITE-SuperIO.git]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
        <tag>SuperIO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESXi6.7安装ROS软路由-设置网卡桥接]]></title>
    <url>%2Fposts%2F1cf14ed3%2F</url>
    <content type="text"><![CDATA[======================================================= 《VMware Esxi 6.7如何安装》 《ESXI iKuai/LEDE双路由系统安装》 《ESXI 群晖NAS/LEDE路由系统安装》 《ESXI ROS路由系统安装》 ======================================================= RouterOS介绍MikroTik RouterOS是一种路由操作系统，是基于Linux核心开发，兼容x86 PC的路由软件,并通过该软件将标准的PC电脑变成专业路由器，在软件RouterOS 软路由图的开发和应用上不断的更新和发展，软件经历了多次更新和改进，使其功能在不断增强和完善。特别在无线、认证、策略路由、带宽控制和防火墙过滤等功能上有着非常突出的功能，其极高的性价比，受到许多网络人士的青睐。 准备工作6网工控机一台，CPU 3865U、内存金士顿4G DDR4、东芝 60G mSATA（已安装了ESXI6.7） 虚拟机镜像请自行下载，这里我使用的版本是 MikroTik RouterOS-v6.19.ova 工控机网卡芯片I211AT，在物理机上用U盘和NetInstall都没安装成功 ESXI直通5个网卡后ROS也无法识别到，百度搜索没有找到解决办法，这里不使用直通，用虚拟网卡绑定物理网卡 创建ROS虚拟机选择从OVF或OVA文件部署 输入名称后，直接将OVA文件拖入 然后一直下一步，近期任务中虚拟机会自动生成，这时候不要刷新页面，完成后虚拟机自动开机先关闭 配置ROS虚拟机CPU建议划分多点，网络需要消耗CPU资源 内存1G，勾选预留，添加所有的网络适配器 至此，ROS已经安装完成了！ 系统初始账号是admin，初始密码是空 配置网络 打开WinBOX工具，用户admin，密码为空 修改网卡名称：点击接口——双击ether*——修改Name——确定(为了好看而已) 设置网桥： 点击网桥(brideg1)——STP(rtsp)——确定 点击协议——添加接口(LAN1)——Edge(yes)——确定，依次添加LAN2——LAN5 点击过滤器——选择接口(LAN1,LAN5)——动作(drop) 设置IP地址池：IP——池——输入IP范围，网桥使用192.168.10.1 设置IP地址：IP——地址——输入IP/广播——接口(brideg1) DHCP服务：接口(bridge)——地址池(dhcp)——ARP勾选——网关/DNS服务器 现在已经可以获取到IP了，但是还不能上网，需要设置一下防火墙 防火墙设置：NAT伪装与DNS NAT：IP——防火墙——NAT——常规(srcnat)——动作(masquerade) DNS：勾选允许远程请求 最后让软路由做出口通道，这里已经建好了 测试已经可以正常上网使用了 本教程至此结束！]]></content>
      <categories>
        <category>VMware EXSI</category>
      </categories>
      <tags>
        <tag>ESXI</tag>
        <tag>ROS</tag>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下常用压缩命令]]></title>
    <url>%2Fposts%2F735f53da%2F</url>
    <content type="text"><![CDATA[记录一些Linux下常用的解压缩命令，以便查找 tar格式解包：$ tar xvf FileName.tar打包：$ tar cvf FileName.tar DirName gz格式解压1：$ gunzip FileName.gz解压2：$ gzip -d FileName.gz压 缩：$ gzip FileName tar.gz格式解压：$ tar zxvf FileName.tar.gz压缩：$ tar zcvf FileName.tar.gz DirName bz2格式解压1：$ bzip2 -d FileName.bz2解压2：$ bunzip2 FileName.bz2压 缩： $ bzip2 -z FileName tar.bz2格式解压：$ tar jxvf FileName.tar.bz2压缩：$ tar jcvf FileName.tar.bz2 DirName bz格式解压1：$ bzip2 -d FileName.bz解压2：$ bunzip2 FileName.bz tar.bz格式解压：$ tar jxvf FileName.tar.bz Z格式解压：$ uncompress FileName.Z压缩：$ compress FileName tar.Z格式解压：$ tar Zxvf FileName.tar.Z压缩：$ tar Zcvf FileName.tar.Z DirName tgz格式解压：$ tar zxvf FileName.tgz tar.tgz格式解压：$ tar zxvf FileName.tar.tgz压缩：$ tar zcvf FileName.tar.tgz FileName zip格式解压：$ unzip FileName.zip压缩：$ leName.zip DirName lha格式解压：$ FileName.lha压缩：$ FileName.lha FileName rar格式解压：$rar a FileName.rar压缩：$ FileName.rar RAR下载地址：http://www.rarsoft.com/download.htm解压后请将rar_static拷贝到/usr/bin目录：$ cp rar_static /usr/bin/rar]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Liunx学习笔记 实现一个misc设备驱动]]></title>
    <url>%2Fposts%2Fdd97f106%2F</url>
    <content type="text"><![CDATA[系统环境如下： 123456789101112131415161718 ./+o+- root@linux yyyyy- -yyyyyy+ OS: Ubuntu 18.04 bionic ://+//////-yyyyyyo Kernel: x86_64 Linux 5.0.6-laohu-v1.0 .++ .:/++++++/-.+sss/` Uptime: 1h 16m .:++o: /++++++++/:--:/- Packages: 2048 o:+o+:++.`..```.-/oo+++++/ Shell: bash .:+o:+o/. `+sssoo+/ Resolution: 2560x1080 .++/+:+oo+o:` /sssooo. WM: GNOME Shell/+++//+:`oo+o /::--:. WM Theme: Adwaita\+/+o+++`o++o ++////. CPU: Intel Core i5-4308U @ 4x 3.3GHz [27.8°C] .++.o+++oo+:` /dddhhh. GPU: intel .+.o+oo:. `oddhhhh+ RAM: 1798MiB / 3862MiB \+.++o+o``-````.:ohdhhhhh+ `:o+++ `ohhhhhhhhyo++os: .o:`.syhhhhhhh/.oo++o` /osyyyyyyo++ooo+++/ ````` +oo+++o\: `oo++. 为什么要学习misc设备的编程?因为，如果我们 每个驱动设备都要像最初那样子去写一个字符设备驱动一样，要分配主设备号，次设备号，实现对应的文件操作函数等等的步骤，未免就有点多了，而且也不好记住它，为此，Linux内核提供了一系列偷懒的技巧，那就是实现了misc设备,其实misc设备，也算是字符设备，只不过对字符设备进行了封装，看看下面的介绍就知道了。 打开内核/include/linux/miscdevice.h 找到misc设备的结构体: 1234567891011121314struct miscdevice &#123; //次设备号一般赋值为MISC_DYNAMIC_MINOR----&gt;由内核自动去分配次设备号 int minor; //misc设备的名称 const char *name; //文件操作结构体 const struct file_operations *fops; struct list_head list; struct device *parent; struct device *this_device; const struct attribute_group **groups; const char *nodename; umode_t mode;&#125;; 这里我只实现最简单的misc设备，只需要关注minor(次设备号),name(设备名称),fops(文件操作函数).misc设备是对字符设备做了一个再次的封装，而且，在misc设备中，主设备号都是一样的，都是10，只有次设备号不同，当我们不知道内核中应该去分配那个此设备号时，可以直接给minor赋值为MISC_DYNAMIC_MINOR这个宏，意思就是由内核来帮我们分配次设备号。name就不用说了，如果设备注册成功，在根文件系统/dev/下就会有注册设备后的name。fops就是一系列的文件操作函数啦，什么open , read ,write , ioctl等等，很多,跟写字符设备是一样的 驱动实现源码代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include&lt;linux/kernel.h&gt;#include&lt;linux/module.h&gt;#include&lt;linux/miscdevice.h&gt;#include&lt;linux/fs.h&gt;#define DEVICE_NAME &quot;my_misc_dev&quot;//实现open函数int my_misc_dev_open(struct inode *inode, struct file *filp)&#123; printk(&quot;minipc misc dev open!\n&quot;); return 0 ;&#125;//实现close函数int my_misc_dev_close(struct inode *inode, struct file *filp)&#123; printk(&quot;minipc misc dev close!\n&quot;); return 0 ;&#125;//初始化文件操作结构体struct file_operations file_ops = &#123; .owner = THIS_MODULE, .open = my_misc_dev_open, .release = my_misc_dev_close,&#125;;//初始化misc设备结构体struct miscdevice my_misc_dev = &#123; //由内核自动分配次设备号 .minor = MISC_DYNAMIC_MINOR , //初始化设备名称 .name = DEVICE_NAME , //初始化文件操作结构体 .fops = &amp;file_ops, &#125;;static int __init my_misc_dev_init(void) &#123; int ret_error ; //注册misc设备 int ret = misc_register(&amp;my_misc_dev); if(ret != 0)&#123; ret_error = ret ; printk(&quot;misc register fair!\n&quot;); goto fair ; &#125; printk(&quot;misc init success!\n&quot;); return ret ;fair: return ret_error ;&#125; static void __exit my_misc_dev_exit(void) &#123; //注销misc设备 misc_deregister(&amp;my_misc_dev);&#125;module_init(my_misc_dev_init);module_exit(my_misc_dev_exit);MODULE_LICENSE(&quot;GPL&quot;);MODULE_AUTHOR(&quot;LAOHU add misc driver&quot;); Makefile: 1234567891011121314151617181920TARGET ?= $(shell uname -r)KERNEL_MODULES ?= /lib/modules/$(TARGET)KERNEL_BUILD ?= $(KERNEL_MODULES)/buildSYSTEM_MAP ?= $(KERNEL_BUILD)/System.mapDRIVER := my_miscobj-m := $(patsubst %,%.o,$(DRIVER))obj-ko := $(patsubst %,%.ko,$(DRIVER))MAKEFLAGS += --no-print-directory.PHONY: all modules cleanall: modules# Targets for running make directly in the external module directory:modules clean: @$(MAKE) -C $(KERNEL_BUILD) M=$(CURDIR) $@ 编译程序，加载驱动，可以看到设备注册成功，主设备号：10，次设备号55 ![misc](Linux驱动学习笔记-实现一个misc设备驱动/misc 01.png)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>drive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记(实现一个带read,write,ioctl的字符设备驱动)]]></title>
    <url>%2Fposts%2Ff38e199%2F</url>
    <content type="text"><![CDATA[运行环境 字符设备基础知识写一个简单的字符驱动程序，需要内核里的以下几个头文件，因为需要调用一些基本的宏和一些基本的函数来使用。 123#include &lt;linux/cdev.h&gt;#include &lt;linux/kdev_t.h&gt;#include &lt;linux/fs.h&gt; 进入Linux内核源码，进入include/linux/，打开cdev.h 123456789struct cdev &#123; struct kobject kobj;//设备模型相关的 struct module *owner;//所属于哪个模块---&gt;THIS MODULE //利用file_operations跟用户态进行操作---&gt;有open , read , write 等方法 const struct file_operations *ops; struct list_head list;//链表,将设备插入到一条链表里去 dev_t dev;/通过设备号匹配对应的驱动 unsigned int count;//要注册字符设备的个数&#125; __randomize_layout; 里面还有部分函数，我们暂时只需要cdev_init,cdev_add,cdev_del。 然后打开kdev_t.h 12345678#define MINORBITS 20#define MINORMASK ((1U &lt;&lt; MINORBITS) - 1)//从设备号中取出主设备号#define MAJOR(dev) ((unsigned int) ((dev) &gt;&gt; MINORBITS))//从设备号中取出次设备号#define MINOR(dev) ((unsigned int) ((dev) &amp; MINORMASK))//创建一个设备号#define MKDEV(ma,mi) (((ma) &lt;&lt; MINORBITS) | (mi)) 创建设备号就需要kdev_t这个宏，创建设备号后还要对设备进行注册，这时候需要fs.h这个头文件里的函数，注册和释放。 1234extern int register_chrdev_region(dev_t, unsigned, const char *);//动态分配设备号，由内核给我们分配一个设备号，这个设备号是内核自动分配的，就不需要我们去使用MKDEV这个宏来进行手动extern int alloc_chrdev_region(dev_t *, unsigned, unsigned, const char *);extern void unregister_chrdev_region(dev_t, unsigned); 编写简单的字符设备需要以下步骤： 创建设备号 注册设备号 退出驱动时，注销设备 创建设备文件，利用cat /proc/devices可以查看申请到的设备名、设备号，这里贴出部分代码： 12345678910111213141516171819202122232425//创建一个字符设备struct char_dev&#123; struct cdev c_dev; dev_t dev_no; char buf[1024];&#125;;struct char_dev *my_dev;static int __init cdev_test_init(void)&#123; int ret; //创建设备号-&gt;主设备号，次设备号 //dev_no = MKDEV(222,2); //注册设备号 //ret = register_chrdev_region(dev_no,1,&quot;my_dev&quot;); //1.给字符设备分配内存空间 my_dev = kmalloc(sizeof(*my_dev),GFP_KERNEL); //2.自动申请设备号并注册字符设备 ret = alloc_chrdev_region(&amp;my_dev-&gt;dev_no,1,1,&quot;my_dev&quot;); //3.初始化字符设备 cdev_init(&amp;my_dev-&gt;c_dev, &amp;my_ops); //4.添加一个字符设备 ret = cdev_add(&amp;my_dev-&gt;c_dev, my_dev-&gt;dev_no, 1); return 0;&#125; 自动创建设备节点利用udev（mdev）来实现设备文件的自动创建，首先应保证支持udev（mdev），由busybox配置。 在驱动用加入对udev 的支持主要做的就是：在驱动初始化的代码里调用class_create(…)为该设备创建一个class，再为每个设备调用device_create(…)创建对应的设备。 内核中定义的struct class结构体，顾名思义，一个struct class结构体类型变量对应一个类，内核同时提供了class_create(…)函数，可以用它来创建一个类，这个类存放于sysfs下面，一旦创建好了这个类，再调用 device_create(…)函数来在/dev目录下创建相应的设备节点。 这样，加载模块的时候，用户空间中的udev会自动响应 device_create()函数，去/sysfs下寻找对应的类从而创建设备节点。 这里贴出部分实现代码： 1234567891011121314151617181920struct device *my_device; ...... //5.为该设备创建一个class //这个类存放于sysfs下面，调用device_create函数时会在/dev目录创建相应的设备节点 cls = class_create(THIS_MODULE, &quot;myclass&quot;);//sys/devices/virtual/myclass/my_dev if(IS_ERR(cls)) &#123; unregister_chrdev_region(my_dev-&gt;dev_no,1); return -EBUSY; &#125; //6.创建对应的设备节点 //加载模块时，用户空间的udev会自动响应该函数，去/sysfs下寻找对应的类创建设备节点 my_device = device_create(cls,NULL,my_dev-&gt;dev_no,NULL,&quot;my_dev&quot;);//mknod /dev/my_dev if(IS_ERR(my_device)) &#123; class_destroy(cls); unregister_chrdev_region(my_dev-&gt;dev_no,1); return -EBUSY; &#125; 实现效果如下图： 为驱动添加open()、read()、write()、ioctl()函数当一个字符设备被注册后，我们随即就要来操作这个字符设备，open , read , write , close等操作，需要file_operations这个结构体： 1234567891011121314151617181920212223static const struct file_operations __fops = &#123; \ .owner = THIS_MODULE, \ .open = __fops ## _open, \ .release = simple_attr_release, \ .read = simple_attr_read, \ .write = simple_attr_write, \ .llseek = generic_file_llseek, \&#125;struct file_operations &#123; struct module *owner; loff_t (*llseek) (struct file *, loff_t, int); ssize_t (*read) (struct file *, char __user *, size_t, loff_t *); ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *); ssize_t (*read_iter) (struct kiocb *, struct iov_iter *); ssize_t (*write_iter) (struct kiocb *, struct iov_iter *); int (*iterate) (struct file *, struct dir_context *); int (*iterate_shared) (struct file *, struct dir_context *); __poll_t (*poll) (struct file *, struct poll_table_struct *); long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long); long (*compat_ioctl) (struct file *, unsigned int, unsigned long); int (*mmap) (struct file *, struct vm_area_struct *); ...... 那么内核是如何去识别相应的函数呢？ 是通过系统调用 在上层应用程序，打个比方。 通过open()打印相应的设备，那么syscall函数就会通过系统调用号识别到内核态里的函数，进而调用到我们这里实现的my_open,这就是内核态和用户态相互沟通的方式 这里贴出部分代码： 123456789101112131415//创建函数，这里就不写出具体实现了int my_open(struct inode *inode, struct file *file)&#123;...&#125;int my_close(struct inode *inode, struct file *file)&#123;...&#125;ssize_t my_read(struct file *file,char __user *buf,size_t len,loff_t *pos)&#123;...&#125;ssize_t my_write(struct file *file,const char __user *buf,size_t len,loff_t *pos)&#123;...&#125;long my_ioctl(struct file *file,unsigned int cmd,unsigned long arg)&#123;...&#125;struct file_operations my_ops = &#123; .open = my_open, .read = my_read, .write = my_write, .unlocked_ioctl = my_ioctl, .release = my_close,&#125;;//初始化opscdev_init(&amp;my_dev-&gt;c_dev, &amp;my_ops); 最终效果图 项目源码地址：https://github.com/huchanghui123/my_cdev 参考博客： https://blog.csdn.net/zqixiao_09/article/details/50839042 https://blog.csdn.net/morixinguan/article/details/55002774]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>drive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux学习笔记（编译一个hello world模块)]]></title>
    <url>%2Fposts%2F392a68e4%2F</url>
    <content type="text"><![CDATA[最近看了篇编写Linux驱动的文章，觉得不错，于是自己动手试了试，这里记录一下以便以后查阅 123456789101112131415161718 ./+o+- root@linux yyyyy- -yyyyyy+ OS: Ubuntu 18.04 bionic ://+//////-yyyyyyo Kernel: x86_64 Linux 5.0.6-laohu-v1.0 .++ .:/++++++/-.+sss/` Uptime: 1d 5h 41m .:++o: /++++++++/:--:/- Packages: 2044 o:+o+:++.`..```.-/oo+++++/ Shell: bash .:+o:+o/. `+sssoo+/ Resolution: 2560x1080 .++/+:+oo+o:` /sssooo. WM: GNOME Shell/+++//+:`oo+o /::--:. WM Theme: Adwaita\+/+o+++`o++o ++////. CPU: Intel Core i5-4308U @ 4x 3.3GHz [27.8°C] .++.o+++oo+:` /dddhhh. GPU: intel .+.o+oo:. `oddhhhh+ RAM: 1807MiB / 3862MiB \+.++o+o``-````.:ohdhhhhh+ `:o+++ `ohhhhhhhhyo++os: .o:`.syhhhhhhh/.oo++o` /osyyyyyyo++ooo+++/ ````` +oo+++o\: `oo++. 编写hello world模块代码在内核源码driver目录创一个hello_driver的目录，并分别创建hello_kernel.c、Kconfig、Makefile三个文件 hello_kernel.c代码如下： 1234567891011121314151617#include&lt;linux/kernel.h&gt;#include&lt;linux/module.h&gt;static int __init hello_init(void)&#123; printk(&quot;Hello, kernel instaled!\n&quot;); return 0;&#125;static void __exit hello_cleanup(void)&#123; printk(&quot;Good bye, removed!\n&quot;);&#125;module_init(hello_init);module_exit(hello_cleanup);MODULE_LICENSE(&quot;GPL&quot;); 这里使用内核根目录下的Makefile进行编译，所以这个例程的Makefile非常简单。 Makefile代码如下： 1obj-$(CONFIG_HELLO_KERNEL) += hello_kernel.o Kconfig代码如下： 12345678menu &quot;hello_driver&quot; config HELLO_KERNEL tristate &quot;hello_kernel&quot; default n help if you select, you can use itendmenu menu：配置选项的菜单 config：要配置的参数 tristate：表示有三种状态可配置，M以模块编译，×编译成.o default：默认配置，有y，n，还可以写模块（y if xxmod） help：提示信息，可以自由添加 Kconfig配置有很多，可以copy其他配置多尝试，然后make menuconfig看效果 修改内核配置文件 打开内核源码drivers目录的Kconfig，在endmenu上面添加source &quot;drivers/hello_driver/Kconfig&quot; 在内核源码根目录执行make menuconfig进入Device Drivers，移动到最下面可以看到添加的选项 按回车进入，空格键进行配置 编译前还需要修改内核驱动目录Makefile文件 因为是使用内核源码进行编译，所以需要将新增的hello_driver目录添加到内核源码drivers的Makefile里 编译内核代码 内核跟目录下执行make -j4，生成驱动模块 123root@linux:/zdisk/linux-5.0.6/drivers/hello_driver# lshello_kernel.c hello_kernel.mod.c hello_kernel.o Makefilehello_kernel.ko hello_kernel.mod.o Kconfig modules.order 验证结果为了方便，这里手动加载/卸载驱动文件，insmod hello_kernel.ko/rmmod hello_kernel.ko 输入dmesg，查看日志，有打印hello_driver.c中的字符串。]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>drive</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 安装使用Wine-4.0]]></title>
    <url>%2Fposts%2F7a7278d%2F</url>
    <content type="text"><![CDATA[Wine 介绍Wine （“Wine Is Not an Emulator” 的首字母缩写）是一个能够在多种 POSIX-compliant 操作系统（诸如 Linux，macOS 及 BSD 等）上运行 Windows 应用的兼容层。Wine 不是像虚拟机或者模拟器一样模仿内部的 Windows 逻辑，而是將 Windows API 调用翻译成为动态的 POSIX 调用，免除了性能和其他一些行为的内存占用，让你能够干净地集合 Windows 应用到你的桌面。 安装成功后，软件被默认安装在/opt 中。而该软件的工作空间的目录默认在/home/username/.wine中（默认被隐藏了） ，工作空间目录下存放windows的系统文件。 Wine 安装官网下载地址：https://wiki.winehq.org/Ubuntu 123456sudo dpkg --add-architecture i386 # 64位的系统需要执行此命令wget -nc https://dl.winehq.org/wine-builds/winehq.keysudo apt-key add winehq.keysudo apt-add-repository &apos;deb https://dl.winehq.org/wine-builds/ubuntu/ bionic main&apos;sudo apt updatesudo apt install --install-recommends winehq-stable #安装稳定版 安装完成后，通过wine --version查看版本为4.0 Wine 4.0配置并解决乱码问题在用户环境下输入winecfg进入配置GUI初始化配置时弹出安装wine-mono和wine-gecko 安装提示时，可以选择取消安装。wine-mono 组件的作用是wine用其运行 .NET Framework；wine-gecko组件的作用是wine用其运行IE浏览器。这两个组件大多数windows软件运行时用不到。 乱码问题： wine配置完成后，如果打开winecfg有乱码现象，可以使用以下方法解决： 百度下载字体simsun.ttc 下载好的zip解压到~/.wine/drive_c/windows/Fonts 新建zh.reg，内容如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051REGEDIT4[HKEY_LOCAL_MACHINE\Software\Microsoft\Windows NT\CurrentVersion\FontSubstitutes]&quot;Arial&quot;=&quot;simsun&quot;&quot;Arial CE,238&quot;=&quot;simsun&quot;&quot;Arial CYR,204&quot;=&quot;simsun&quot;&quot;Arial Greek,161&quot;=&quot;simsun&quot;&quot;Arial TUR,162&quot;=&quot;simsun&quot;&quot;Courier New&quot;=&quot;simsun&quot;&quot;Courier New CE,238&quot;=&quot;simsun&quot;&quot;Courier New CYR,204&quot;=&quot;simsun&quot;&quot;Courier New Greek,161&quot;=&quot;simsun&quot;&quot;Courier New TUR,162&quot;=&quot;simsun&quot;&quot;FixedSys&quot;=&quot;simsun&quot;&quot;Helv&quot;=&quot;simsun&quot;&quot;Helvetica&quot;=&quot;simsun&quot;&quot;MS Sans Serif&quot;=&quot;simsun&quot;&quot;MS Shell Dlg&quot;=&quot;simsun&quot;&quot;MS Shell Dlg 2&quot;=&quot;simsun&quot;&quot;System&quot;=&quot;simsun&quot;&quot;Tahoma&quot;=&quot;simsun&quot;&quot;Times&quot;=&quot;simsun&quot;&quot;Times New Roman CE,238&quot;=&quot;simsun&quot;&quot;Times New Roman CYR,204&quot;=&quot;simsun&quot;&quot;Times New Roman Greek,161&quot;=&quot;simsun&quot;&quot;Times New Roman TUR,162&quot;=&quot;simsun&quot;&quot;Tms Rmn&quot;=&quot;simsun&quot; 在终端执行regedit zh.reg 再次运行winecfg命令，wine可以正常支持中文了 Win 4.0运行Windows 程序下载windows应用程序LinX（解压） 12laohu@linux:/zdisk/test_tools/Linx$ lschangelog.txt linpack_xeon32.exe linpack_xeon64.exe LinX.exe LinX.ini readme.txt Speedfan.ini 输入命令wine LinX.exe，使用正常 下载FurMark_1.20.4.0_Setup.exe（安装程序）右键使用wine windows打开，安装路径使用默认 Win 4.0卸载 卸载软件 12sudo apt remove wine两次Tab键，列出所有安装的与wine相关的软件，然后全部卸载sudo apt autoremove #清理依赖包软件包 删除工作目录和软件安装目录 12sudo rm -r ~/.wine #删除工作目录sudo rm -r /opt/wine-* #删除软件安装目录 全局搜索所有与wine有关的所有文件和目录：删除即可(注意不要删除) 123sudo find ~ -iname *wine* #查询 家目录下所有名字中含有wine的目录或文件sudo find / -iname *wine* #查询 跟目录下所有名字中含有wine的目录或文件sudo find path -iname *wine* -exec rm -r &#123;&#125; \; #把搜索到的文件一并删除(注意)]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QOTOM MiniPc Window Server 2008 r2 I211AT网卡驱动安装]]></title>
    <url>%2Fposts%2F412022ec%2F</url>
    <content type="text"><![CDATA[*型号：Q350P Mini Pc * 系统：Windows Server 2008 r2 Enterprise 打开管理工具，找到网卡，右键update Driver，从设备列表中选择 找到网络适配器Network adapters，点击Next 厂家选择Intel，适配器选择Intel I210，点击NextQ350P使用的网卡为Intel I211AT，Window Server 2008 默认没有集成该网卡驱动，并且英特尔官方也没有推出该网卡的Window Server版驱动，以后应该也不会推出，这里可以使用I210驱动，将网卡识别成Inel I210使用 网卡驱动安装成功 经测试可以正常获取到IP，并且可以访问互联网 本教程到此结束！]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QOTOM MiniPc Windows Server 2016 驱动安装]]></title>
    <url>%2Fposts%2F73f08017%2F</url>
    <content type="text"><![CDATA[硬件：QOTOM Q515G6 Mini Pc 系统：windows server 2016 180天试用版 windows server 2016 180天试用版 &lt;https://www.microsoft.com/zh-cn/evalcenter/evaluate-windows-server-2016 Windows Server安装完成启动后，发现设备管理器很多设备没有驱动 首先更新网卡驱动，Q515G6 网卡使用的是Intel I211AT网卡芯片，下载Windows-Server版网卡驱动：https://github.com/FerdinandvHagen/I211AT-Windows-Server-2016 打开Powershell终端，输入以下命令，可禁用驱动程序强制签名 123bcdedit /set LOADOPTIONS DISABLE_INTEGRITY_CHECKSbcdedit /set TESTSIGNING ONbcdedit /set NOINTEGRITYCHECKS ON 然后重启电脑，将下载好的驱动放在C盘根目录，开始安装驱动 右击网卡设备——&gt;更新驱动 选择下载好的驱动文件夹 点击Next，选择第二项 驱动安装成功 依次安装其他网卡驱动程序，注意网卡序号跟接口位置并不匹配，我这里网卡1绑定的是4号 至此，6个网卡都可以正常使用了，接下来更新系统 更新系统过程中会安装一些其他驱动，感叹号终于全不见了 最后将校验驱动签名的功能打开 123bcdedit /set LOADOPTIONS ENABLE_INTEGRITY_CHECKSbcdedit /set TESTSIGNING OFFbcdedit /set NOINTEGRITYCHECKS OFF 希望本教程能够对你有所帮助！]]></content>
      <categories>
        <category>Windows</category>
      </categories>
      <tags>
        <tag>Windows</tag>
        <tag>Mini Pc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeBSD12 Atheros 无线网卡AP模式设置]]></title>
    <url>%2Fposts%2F892e18ba%2F</url>
    <content type="text"><![CDATA[内核版本： 12# uname -aFreeBSD XMAN 12.0-RELEASE FreeBSD 12.0-RELEASE r341666 GENERIC amd64 驱动设置找到要使用的驱动程序ath0 12# sysctl net.wlan.devicesnet.wlan.devices: ath0 可以通过下面的命令找到相应的硬件： 12345# pciconf -lv ath0ath0@pci0:2:0:0: class=0x028000 card=0xe052105b chip=0x0034168c rev=0x01 hdr=0x00 vendor = &apos;Qualcomm Atheros&apos; device = &apos;AR9462 Wireless Network Adapter&apos; class = network 加载模块，修改 /boot/loader.conf 后reboot重启 1234567# cat /boot/loader.confif_ath_load=&quot;YES&quot;if_wi_load=&quot;YES&quot;if_ath_pci_load=&quot;YES&quot;wlan_wep_load=&quot;YES&quot;wlan_ccmp_load=&quot;YES&quot;wlan_tkip_load=&quot;YES&quot; 无线AP设置加载无线网络支持后，检查无线设备是否支持基于主机的接入点模式，也称为hostap模式: 12345# ifconfig wlan0 create wlandev ath0# ifconfig wlan0 list capsdrivercaps=4f8def41&lt;STA,FF,IBSS,PMGT,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,TXFRAG&gt;cryptocaps=1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;htcaps=20701ef&lt;LDPC,CHWIDTH40,SHORTGI20,SHORTGI40,TXSTBC&gt; 这里打印了 HOSTAP，证实了这张无线网卡可以充当AP。还列出了各种支持的加密方式：WEP， TKIP和AES。此信息指示可以在AP上使用哪些安全协议。 无线设备只能在创建网络设备时进入hostap模式，因此必须首先销毁先前创建的设备: 1# ifconfig wlan0 destroy 然后在设置其他参数之前使用正确的选项重新生成: 12# ifconfig wlan0 create wlandev ath0 wlanmode hostap# ifconfig wlan0 inet 10.10.10.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1 再次通过ifconfig 查看wlan0接口状态： 123456789101112# ifconfig wlan0wlan0: flags=8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500 ether 3c:77:e6:50:2a:69 inet 10.10.10.1 netmask 0xffffff00 broadcast 10.10.10.255 groups: wlan ssid freebsdap channel 1 (2412 MHz 11g ht/20) bssid 3c:77:e6:50:2a:69 regdomain 108 indoor ecm authmode OPEN privacy OFF txpower 20 scanvalid 60 protmode CTS ampdulimit 64k ampdudensity 8 shortgi wme burst dtimperiod 1 -dfs media: IEEE 802.11 Wireless Ethernet autoselect mode 11ng &lt;hostap&gt; status: running nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt; 将下面的参数添加到 /etc/rc.conf ，在引导时自动完成配置： 1234wlans_ath0=&quot;wlan0&quot;hostapd_enable=&quot;YES&quot;create_args_wlan0=&quot;wlanmode hostap&quot;ifconfig_wlan0=&quot;inet 10.10.10.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&quot; 还需要配置WPA2安全协议，这样才能安全运行AP 配置 /etc/hostapd.conf : 12345678910# vim /etc/hostapd.confinterface=wlan0debug=1ctrl_interface=/var/run/hostapdctrl_interface_group=wheelssid=freebasapwpa=2wpa_passphrase=freebsdmall #passwordwpa_key_mgmt=WPA-PSKwpa_pairwise=CCMP 启动hostapd服务 123456# service hostapd forcestartStarting hostapd.Configuration file: /etc/hostapd.confUsing interface wlan0 with hwaddr 3c:77:e6:50:2a:69 and ssid &quot;freebasap&quot;wlan0: interface state UNINITIALIZED-&gt;ENABLEDwlan0: AP-ENABLED 到了这一步移动设备应该可以看到SSID了，也可以对接入点进行身份验证，但是只能通过设置静态IP连接，并且无法连接公网 无线DHCP服务设置设置DHCP服务器，需要使用DHCPd守护程序监听wlan0接口的ip地址： 安装ISC的dhcpd服务器： 12cd usr/ports/net/isc-dhcp44-server/make install clean 执行上述指令后将出现如下画面 使用默认设置即可 安装完后，在 /usr/local/etc/ 生成dhcpd.conf.sample 和 dhcpd.conf 我们对dhcpd.conf进行修改 1234567891011121314151617# cat usr/local/etc/dhcpd.confoption domain-name &quot;freebsd.org&quot;;option domain-name-servers 8.8.8.8;default-lease-time 86400;max-lease-time 86400;log-facility local7;ddns-update-style none;subnet 10.10.10.0 netmask 255.255.255.0 &#123; range 10.10.10.100 10.10.10.150; option domain-name-servers 8.8.8.8; option domain-name &quot;freebsd.org&quot;; option routers 10.10.10.1; option broadcast-address 10.10.10.255; default-lease-time 3600; max-lease-time 7200;&#125; 启动服务 service isc-dhcpd start 后连接AP，移动设备可以自动获取到ip，但还不能访问网络 12345678910111213# service isc-dhcpd startStarting dhcpd.Internet Systems Consortium DHCP Server 4.4.1Copyright 2004-2018 Internet Systems Consortium.All rights reserved.For info, please visit https://www.isc.org/software/dhcp/Config file: /usr/local/etc/dhcpd.confDatabase file: /var/db/dhcpd/dhcpd.leasesPID file: /var/run/dhcpd/dhcpd.pidWrote 0 leases to leases file.Listening on BPF/wlan0/3c:77:e6:50:2a:69/10.10.10.0/24Sending on BPF/wlan0/3c:77:e6:50:2a:69/10.10.10.0/24Sending on Socket/fallback/fallback-net FreeBSD PF防火墙设设置启动FreeBSD的网关模式，允许数据包从wifi转发到lan口，修改配置 /etc/rc.conf 123456789## allow packets to be passed from one network interface to anothergateway_enable=&quot;YES&quot; # Enable as LAN gateway## PF firewallpf_enable=&quot;YES&quot; # Enable PF (load module if required)pf_rules=&quot;/etc/pf.conf&quot; # rules definition file for pfpf_flags=&quot;&quot; # additional flags for pfctl start uppflog_enable=&quot;YES&quot; # To enable logging supportpflog_logfile=&quot;/var/log/pflog&quot; # where pflogd should store the logfilepflog_flags=&quot;&quot; # additional flags for pflogd start up 保存所需的编辑后，可以通过键入以下内容 来启动PF以获取日志记录支持： 12# service pf start# service pflog start 启用网关数据转发，转发IPV4数据包： 12# sysctl net.inet.ip.forwarding=1 #forward IPv4 packets# sysctl net.inet6.ip6.forwarding=1 ##IPV6 注意如果要转发IPV6，在 /etc/rc.conf 中需要添加 ipv6_gateway_enable =“YES” FreeBSD安装包 示例文件路径： /usr/share/examples/pf/以下是个简单的Pf防火墙配置，允许所有通过无线网卡的数据包到有线网卡LAN。有线网卡是igb0接口，无线网卡是wlan0接口。 1234567891011121314151617# vim etc/pf.conf#block in all #pass out all keep state #allows all#interfaceslan_if=&quot;igb0&quot;wifi_if=&quot;wlan0&quot;localnet=$wifi_if:network#NATnat on $lan_if from $localnet to any -&gt; ($lan_if)block allblock in log allpass out log quick#pass inet4 and inet6 traffic in on wifi and lanpass in log on $wifi_if inetpass in log on $lan_if inetpass from &#123;lo0, $localnet&#125; to any keep state 执行 pfctl -f /etc/pf.conf 刷新过滤器，连接WIFI就可以访问网络了。 无线连接接入完成！参考文档1：https://www.freebsd.org/doc/handbook/network-wireless.html 参考文档2：https://calomel.org/freebsd_wireless_access_point.html]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>FreeBSD</tag>
        <tag>Unix</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ESXi6.7 安装群晖NAS/LEDE路由系统]]></title>
    <url>%2Fposts%2Fe303e8c3%2F</url>
    <content type="text"><![CDATA[======================================================= 《VMware Esxi 6.7如何安装》 《ESXI iKuai/LEDE双路由系统安装》 《ESXI 群晖NAS/LEDE路由系统安装》 《ESXI ROS路由系统安装》 ======================================================= 安装环境工控迷你PC一台，CPU 3865U（支持VT-d） 东芝 60G mSATA（已安装了ESXI6.7、LEDE X86），安装方法可以参考我上一篇文章 一块500G 2.5寸HDD （硬盘直通） 黑群晖引导链接： https://pan.baidu.com/s/1zRtZXtq2TX58w2NoTyAvKQ 提取码: s7z9 虚拟机安装步骤 首先将下载的.img引导文件使用StarWindConverter转换为ESXI可用的.vmdk文件备用 打开StarWind点击local file——&gt;选择下载好的lede镜像文件——&gt;选择ESX SERVER IMAGE 新建ESXI虚机：选择linux、Red Hat Enterprise Linux 7 (64 位)，然后下一步 CPU和内存按实际情况修改（1G够了），按顺序删除默认硬盘、SCSI控制器、CD/DVD驱动器，修改网卡为E1000e后点下一步后保存 然后点击左侧存储——&gt;数据存储浏览器——&gt;选择目录DSM——&gt;上传转换的镜像文件（两个会自动合并） 接下来做硬盘直通，用ssh连上ESXI（设置打开ESXi Shell：Troubleshooting Mode Options 选项卡第二项 Enable SSH） 接好硬盘后ESXi要重启下才能识别到硬盘，然后分别复制下面的磁盘路径 打开Putty连接ESXi，在控制台输入vmkfstools -z 路径1 路径2/xxx.vmdk，如果没错误提示就说明直通成功了 进入数据存储——&gt;数据存储浏览器，刚刚直通的vmdk就可以看到了 返回虚拟机，编辑设置，添加现有硬盘，分别选择DSM6.2.1目录下的synoboot镜像和根目录的wd_hdd，然后保存 打开DSM虚拟机，准备初始化 打开虚拟机，出现如下界面，说明已经正常启动 可以输入http://find.synologt.com搜索 在LEDE中查看DHCP也可以知道具体的ip地址，可直接访问 群晖NAS安装 进入安装界面后点击立即安装，勾选提示，点击确定 等待下载安装，会有十分钟的倒计时等待，一般到6-7分钟就可以访问地址了 进入系统安装界面，根据提示进行相关设置完成黑群晖的安装 配置完成后进入系统，已经是最新版群晖 有多个磁盘的话可以使用minipcie转sata，经测试也可以正常直通 但不能识别成固态硬盘，具体原因未知… 本教程到此结束！]]></content>
      <categories>
        <category>VMware EXSI</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>EXSI</tag>
        <tag>Synology</tag>
        <tag>NAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工控迷你PC打造iKuai/LEDE双路由系统，实现多拨、宽带叠加、科学上网]]></title>
    <url>%2Fposts%2F86171f25%2F</url>
    <content type="text"><![CDATA[======================================================= 《VMware Esxi 6.7如何安装》 《ESXI iKuai/LEDE双路由系统安装》 《ESXI 群晖NAS/LEDE路由系统安装》 《ESXI ROS路由系统安装》 ======================================================= 前期准备工作：6网迷你电脑一台，CPU 3865，支持VT-D技术，内存三星8G，东芝60G mSATA，测试电脑一台 StarWind V2V Image Converter（转换镜像为exsi专用）请google自行下载 爱快镜像：https://www.ikuai8.com/component/download（64位ISO） lede镜像：http://firmware.koolshare.cn/LEDE_X64_fw867（虚拟机转盘或PE下写盘专用） EXSI的安装可以参考《VMware Esxi 6.7如何安装》 第一步：转换镜像转换步骤很简单就不一一截图了。 打开StarWind点击local file 选择下载好的lede镜像文件 选择ESX SERVER IMAGE 最终转换成功的效果图 第二步：ESXI创建虚拟机 工控机网口1、网口6分别接上电脑和外网，进入ESXI配置页面 管理-硬件-PCI设备-切换直通（据说能“网卡性能最大化”），LAN1不要勾选（用于管理虚拟机），剩余的网卡全部勾选，然后重新引导主机 重启完成后，点击网络——虚拟交换机——安全——勾选混杂模式 打开存储——数据存储浏览器——创建目录（aikuai/lede）——分别上传爱快iso和lede vmdk镜像文件 创建爱快虚拟机，操作系统选择Linux CPU配置2，内存配置4GB，勾选预留所有客户机内存，硬盘配置2GB，CD/DVD驱动器选择上传的爱快ISO，添加一个PCI设备，选择6号网卡作为WAN口 创建LEDE虚拟机（客户机操作系统与爱快设置一样） CPU配置2，内存配置1GB，勾选预留所有客户机内存，删除硬盘，添加现有硬盘，选择上传的LEDE镜像 添加4个PCI设备，分别绑定网卡2、网卡3、网卡4、网卡5 虚拟机创建完成 第三步：配置虚拟机 打开爱快虚拟机，按提示安装，安装完成界面如下 输入编号2设置LAN地址10.10.10.10，按回车，完成后如下图 设置网卡绑定 先拔掉WAN口的网线确认对应的网卡，这里确认网口1是对应eth1 输入1设置网卡 绑定完成，接下来可以进入爱快web管理页面了 浏览器输入管理地址：10.10.10.10，账号密码默认admin/admin 网络设置——外网设置——绑定网卡eth0（先不要插上，会显示空闲） 如果要使用多播的话选择基于物理网卡的多拨，由于我是接的交换机，这里选择DHCP，然后保存刷新就已经自动连上了 DHCP设置，注意这里的网关设置是LEDE的地址 打开LEDE虚拟机，配置网络 输入vim ect/config/network打开网络配置 按insert进入插入模式，将接口lan的网关改位10.10.10.11 按esc，输入：wq保存退出 输入reboot重启或者输入/etc/init.d/network restart重启网络 重启完成后，在浏览器输入10.10.10.11，默认密码koolshare登录LEDE 绑定网卡 网络——接口——物理设置——接口 WAN口由爱快提供，绑定成其他网卡，删除掉 点击网络——接口——编辑，设置IPV4网关，DNS与爱快一样，DHCP服务器设置关闭 进入酷软中心，安装科学上网插件，如果能安装成功，说明网络是OK的 插件设置我就不介绍了，可以百度SSR使用教程，用SSR链接解析并保存为节点 将电脑ip需修改为自动获取ip，可以发现网关变为LEDE后台地址了，如果设置好科学上网，国内国外的网络就都可以访问了 这里LEDE只是作为一个交换机了，只要终端网关是LEDE的IP，数据流量都会通过LEDE最终发至爱快的LAN口 电脑——&gt;LEDE网关——&gt;爱快网关 参考了Vedio Talk的视频教程：https://www.youtube.com/watch?v=WD1T1S8FYS4&amp;t=124s]]></content>
      <categories>
        <category>VMware EXSI</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>EXSI</tag>
        <tag>Router</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeNAS 创建SMB共享]]></title>
    <url>%2Fposts%2F3fe514f1%2F</url>
    <content type="text"><![CDATA[======================================================= 《FreeNAS如何安装》 《FreeNAS-创建和删除卷》 《FreeNAS-创建SMB共享》 ======================================================= ​ 本教程以 FreeNAS 11.2 版本为例创建 SMB 共享，虽然在界面上与 FreeNAS 11.2 之前的版本略有差异，但原理和过程完全一致，权当抛砖引玉，敬请举一反三。为了便于理解，本文将创建 SMB 共享的过程分成以下三个部分。 SMB介绍 ​ Server Message Block - SMB，即服务(器)消息块，是 IBM 公司在 80 年代中期发明的一种文件共享协议。它只是系统之间通信的一种方式（协议），并不是一款特殊的软件。 ​ SMB 协议被设计成为允许计算机通过本地局域网（LAN）在远程主机上读写文件。远程主机上通过 SMB 协议开放访问的目录称为 共享文件夹。 第一部分：新建账户与指定数据集权限​ 本教程主要介绍带基本身份验证的 SMB 共享，即只有输入正确的用户名和密码才可以访问共享目录。 ​ 新建账户的过程非常简单，浏览器访问 WebGUI 管理界面，如下图所示，依次点击 “Account” 账户图标，在账户选项卡中点击 “Users” 选项按钮，然后再点击下方的 “Add User” 添加用户按钮。 下面分别介绍每一选项： User ID:用户ID，在Unix 世界，每一个用户都有一个唯一的ID号，系统会自动生成，我们不用理会，高级用户可以根据需要进行修改。 Username:用户名，必填，不多解释，这一步我们要创建的就是这个东西。不能使用中文，建议英文或英文+数字，不能使用符号。 Create a new primary group for the user:创建同名主用户组，这一项默认是勾选的，在本教程中，我们保持勾选。如果取消勾选，则需要在下一项的列表中，为此用户选择一个主用户组。 Primary Group:主用户组，只有取消了上一项的勾选，这一项才可以进行选择。出于安全原因，如果wheel是用户的主用户组，FreeBSD不会授予该用户su权限。 Create Home Directory In:创建主目录的位置，默认值为 /nonexistent 意为不创建主目录。此处我们保持默认，不需修改。 Shell:命令行，指定要使用的命令行。此处保持默认，不需修改。 Full Name:用户全名，必填，通常在这里填写用户的全名，建议填写英文。 E-mail:用户的电子邮箱，选填。 Password:用户密码，必填，不多解释，给用户设置一个密码，访问共享目录时就是用这个密码进行身份验证。 Password confirmation:确认密码，必填，与上一项输入的密码必须一致。 Disable password login:禁用密码登陆，此处不要勾选。 Lock user:锁定用户，此处不要勾选。当选中时，将禁止用户登录。 Permit Sudo:允许用户使用sudo命令，此处不要勾选。 Microsoft Account:微软账号，如果用户将从Windows 8或更高系统连接，则选中此框。此处可以勾选。 SSH Public Key:SSH公钥，此处不需设置。 Auxiliary groups:辅用户组，此处需要设置。类Unix系统中，每一个用户必须属于一个主用户组，同时可以属于零到多个辅用户组。 这里，我们创建一个名为laohu的用户，密码为123456。 ​ 填写完毕后，点击窗口左下角的 “OK” 确定按钮，用户创建成功后，可以看到，新添加的用户 laohu 已经显示在用户列表中了。 ​ 用户创建成功，接下来设置用于 SMB 共享的数据集。点击 WebGUI 界面上的 “Storage” 存储图标，切换到存储选项卡。系统已经在卷下创建了一个同名的数据集，如下图。你可以直接使用这个数据集用作 SMB 共享，也可以在该数据集下面创建新的数据集，此处为了便于演示，我们直接使用这个名为 myStor 的数据集。 ​ 点选 myStor 数据集，然后点击下方的第一个图标按钮 “Change Permissions” 修改权限，随即弹出如下图所示的修改数据集权限的窗口。此处，我们只需要在 Owner(user)所有者和 Owner(group)所有者组的下拉菜单中选择 laohu 即可，点击 “Change” 确定按钮使设置生效。注：Mode 是详细的权限设定，默认为所有者拥有读写和执行权限，所有者组具有读和执行权限，其他用户和组拥有读和执行权限。现在不用管它，保持默认即可。 简单介绍下各个选项: Apply Owner (user): 应用所有者(用户)。用于对数据集权限进行微调，取消勾选可以防止将新权限变更到数据集所有者(用户)。 Owner (user): 数据集所有者(用户)。从下拉菜单选择数据集的所有者(用户)。 Apply Owner (group): 应用所有者(用户组)。用于对数据集权限进行微调，取消勾选可以防止将新权限变更到数据集所有者(用户组)。 Apply Mode: 应用模式。用于对数据集权限进行微调，取消勾选可以防止将新权限变更到模式。 Mode: 权限模式。仅适用于Unix或Mac，如果下一项权限类型选择Windows，将不可设定具体权限。 Permission Type: 权限类型。可以选择Unix、Mac或Windows ; 请选择与访问卷/数据集的客户端类型相匹配的操作系统。 Set permission recursively: 设置递归权限。如果选中，权限也将应用于卷/数据集的子目录。 到这里，第一部分的操作就完成了，接下来开始创建 SMB 共享。 第二部分：创建共享并启动SMB服务在 WebGUI 管理界面中点击 “Sharing” 共享图标，打开共享列表界面。点击切换到 Windows (SMB) 共享列表。 点击 “Add Windows (SMB) Share” 添加 SMB 共享按钮，弹出如下所示窗口。 我们只需填写以下两项即可： Path：是存储路径，点击右侧的 “Browse” 浏览按钮，找到此共享需要使用的数据集，此处我们选择与卷同名的 myStor 数据集。 Name：共享名称，随意设置，此处设置的名称会显示在共享目录中。图中设置的共享名为 music。 ​ 设置好以后，点击 “OK” 确定按钮后系统会弹出下图所示的提示：是否启用 SMB 服务？我们点击 “Yes” 确定按钮。此时，SMB共享创建完成，系统也自动帮我们启动了 SMB 服务。 第三部分：访问测试 SMB 共享​ 经过前两个部分的设置，SMB 共享就正式创建好了，接下来让我们一起测试一下，看看是否可以正常访问共享目录。此处我们以 Windows 10 系统为例进行演示。 ​ 在测试之前，请首先确认，测试机是否与 FreeNAS 服务器位于同一局域网的相同网段。在本例中，我的 Windows 10 系统 IP 地址为 192.168.1.110，FreeNAS 服务器的 IP 地址为 192.168.1.250。可以看到，他们处于相同的 192.168.1.x 网段。 注：Win10确保SMB 1.0文件共享支持选中，不然可能会找不到freeNAS ​ 双击打开 Windows 10 系统桌面上的“计算机”，在左侧找到并点击“网络”，此时右侧会显示出同一局域网中的所有开放共享的设备。可以看到，FreeNAS 就在其中。注：如果你点击网络后，右侧没有显示任何共享设备，在窗口上方弹出了一个黄色的提示框，询问你是否启用网络发现，请点击提示框，确认启用网络共享和发现服务。 输入正确的用户名密码即可访问共享目录。 如果找不到设备，也可以在文件夹路径栏直接输入\\192.168.1.250访问 输入正确的账号密码后，可以看到我们在创建 SMB 共享时设置的 test 目录。 建立测试文件，测试共享目录 平均传输速度113MB/s，速度不错。 以上就是在FreeNAS中创建SMB共享教程。 参考：https://www.getnas.com/2015/01/20/freenas-the-first-cifs/]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>Unix</tag>
        <tag>FreeNAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeNAS 创建和删除卷]]></title>
    <url>%2Fposts%2F98bad996%2F</url>
    <content type="text"><![CDATA[======================================================= 《FreeNAS如何安装》 《FreeNAS-创建和删除卷》 《FreeNAS-创建SMB共享》 ======================================================= ​ FreeNAS 采用 ZFS 文件系统，因此可以将多块硬盘组织成一个用于存储的卷。不仅如此，在创建卷时，还可以自由指定冗余方案，比如创建一个由四块 4TB 硬盘组成的卷，并指定他们以 RAID Z1 的阵列形式进行组织，此卷的可用存储空间为 12TB，另外的 4TB 用于奇偶校验。这样一来，这个卷下的任何一个硬盘发生损坏，卷中存储的数据都不会丢失。 为FreeNAS创建卷首先在浏览器中打开 WebGUI 管理界面，如下图所示，点击 “Storage” 存储器存储图标，然后点击存储选项卡中的“View Disks”查看磁盘按钮。 如下图所示，在 “View Disks” 选项卡中，列出了系统可以使用的所有硬盘。 点击左侧的 “Volume Manager” 卷管理器按钮,会弹出如下图所示的窗口。 第一项，“Volume Name” 卷名称，文本框中填入你想给卷取的名字，可以随意填写。 第二项，“Volume to extend” 扩展卷，用于给已存在的卷进行扩容的，我们的目的是创建新的卷，此项留空。 第三项，“Encryption” 加密，用于创建加密的卷，这一项暂时不要选中，以后再介绍。 第四项，“Available disks” 可用磁盘，可以看到，一共有2块硬盘。点击+号按钮，即可将磁盘添加到第五项中。 第五项，“Volume layout” 卷结构，用来指定硬盘以何种磁盘阵列形式进行组织。通过左侧的下拉菜单指定磁盘阵列形式，同时拉动右侧那个圆形的小按钮，进行更准确的结构调整。 ​ 如下图所示，如果主机接入了足够多的硬盘，第五项中的下来菜单就会显示出所有可以选择的磁盘阵列形式。需要注意，左侧的下拉菜单中列出的阵列形式，是根据你实际安装的硬盘数量显示的，由于两块硬盘无法组成 RaidZ 形式的阵列，因此，如果你只安装了两块硬盘，则不会显示 RaidZ、RaidZ2、RaidZ3。 由于我一起只有三块硬盘（其中一块系统盘）这里我只能使用mirror。 以下为各种卷结构的创建要求： RAID Z：最少由3块硬盘组成，其中一块硬盘的空间用作奇偶校验，允许一块硬盘损坏，不丢失数据。 RAID Z2：最少由3块硬盘组成，其中两块硬盘的空间用作奇偶校验，允许两块硬盘同时损坏，不丢失数据。 RAID Z3：最少由5块硬盘组成，其中三块硬盘的空间用作奇偶校验，允许三块硬盘同时损坏，不丢失数据。 Mirror 镜像：最少由2块硬盘组成，两块硬盘互作镜像，任何一块硬盘损坏，不丢失数据。 Stripe 带条：最少由1块硬盘组成，该形式无冗余，因此任何硬盘损坏，该卷下的所有数据均会丢失，这种类型的卷唯一有点是读写速度最快。 Log（ZIL）：用于写操作的高速缓存，通常用 SSD 固态硬盘来创建该设备。 Cache（L2ARC）：用于读操作的高速缓存，通常用 SSD 固态硬盘来创建该设备。 Spare：备用设备，此处略过不谈。 你可以根据对数据安全性的要求来决定创建哪一种形式的磁盘阵列，选择好卷结构，卷管理器左下角的 “Add Volume” 添加卷按钮，系统开始创建卷。注意，创建卷的过程会擦出所有已选择硬盘上的数据，创建之前，请务必确保硬盘中没有重要的数据。 ​ 待卷创建完成，存储选项卡的列表中会列出所有的卷，卷创建完成后会自动在该卷下创建一个同名的数据集。你可以把数据集简单的理解为文件夹，它的主要用途是对数据和权限进行归类，如下图所示，可以根据需要，创建多个数据集，数据集支持嵌套，可以分别指定所有权，且数量没有限制，如下图所示。 删除FreeNAS中已创建的卷在 FreeNAS 中，删除卷的操作被形象的称为“分离卷”，意思是将组成某个卷的所有硬盘，从卷中分离出去。分离卷的操作很简单，在存储选项卡的列表中点选要删除的卷，此时列表下方会显示一排功能按钮（将鼠标移动到按钮上会显示每个按钮所代表的功能），可以看到第一个按钮 “Detach Volume” 分离卷。 点击分离卷按钮，会弹出如下图所示的窗口。可以看到，界面的背景变成了红色，代表这是一项危险操作。 ​ 如果希望删除卷的同时清空硬盘中的所有数据，则选中 “Mark the disks as new (destory data) 销毁数据” 选项。注意：这是一个危险的可选操作，如果你在这个卷中存储了敏感数据，可能希望对硬盘执行数据销毁操作。但如果你还希望重新导入这个卷，并且还需要使用这个卷中已存储的数据，则不要勾选此项。 点击 “Yes” 确定按钮，系统会自动将选择的卷删除。 ​ 如果在分离卷时，没有勾选“销毁数据”选项，且分离卷以后，也没有使用分离出来的硬盘再次创建其他的卷。满足上述两种条件，可以使用存储选项卡中的 “Import Volume” 导入卷工具，将这个被分离的卷重新还原回来。 参考：https://www.getnas.com/2015/01/20/freenas-volume-management/]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>Unix</tag>
        <tag>FreeNAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[VMware Esxi 6.7如何安装]]></title>
    <url>%2Fposts%2F21b893a7%2F</url>
    <content type="text"><![CDATA[======================================================= 《VMware Esxi 6.7如何安装》 《ESXI iKuai/LEDE双路由系统安装》 《ESXI 群晖NAS/LEDE路由系统安装》 《ESXI ROS路由系统安装》 ======================================================= VMware VSphere介绍虚拟化打破了物理硬件与操作系统及在其上运行的应用程序之间的硬性连接。操作系统和应用程序在虚拟机中实现虚拟化之后，便不再因位于单台物理计算机中而受到种种束缚。物理元素（如交换机和存储器）的虚拟等效于在可跨越整个企业的虚拟基础架构内运行。 与物理机一样，虚拟机是运行操作系统和应用程序的软件计算机。管理程序用作虚拟机的运行平台，并且可以整合计算资源。每个虚拟机包含自己的虚拟（基于软件的）硬件，包括虚拟CPU、内存、硬盘和网络接口卡。 虚拟化计算机： x86计算机硬件被设计为只能运行单个操作系统和单个应用程序，这导致了大多数计算机未得到充分利用。即使安装了众多应用程序，大多数计算机仍无法得到充分利用。在最基本的层次上，通过虚拟化可以在单台物理计算机上运行多个虚拟机，且所有虚拟机可在多种环境下共享该物理计算机的资源。在同一物理计算机上，不同的虚拟机可以独立、并行运行不同的操作系统和多个应用程序。 下图所示的就是一台物理主机在虚拟化前和虚拟后的差别： 以上介绍转载于：https://blog.csdn.net/Kim_Weir/article/details/80554981 安装过程工控迷你电脑，用于安装虚拟机 制作U盘启动器Rufus 3.3启动盘制作工具 将U盘插入MINIPC，开机按F11选择从U盘启动 选择第一项U盘，按回车 安装程序初始化，检测硬件信息，如不满足会跳出错误提示 检测完成出现如下界面，回车 同意条款，F11继续 出现硬盘信息，选择要安装的磁盘，按回车 键盘模式使用默认 设置root账户密码（注意：vSphere 6.7不再支持简单密码，可以在主机配置中启用简单密码） 按F11开始安装 安装中… 安装完成，拔掉U盘，按回车重启系统 系统重启完成 安装完成进行系统设置 按F2，输入root密码 配置界面如下 选择Configure Management Network进行管理网络配置 可以选择修改管理网络网卡、VLAN、IPv4、IPv6、DNS、DNS域 配置IPV4地址 设置为静态IP，按回车 DNS设置 按ESC，输入Y保存上面的配置信息 继续按ESC 返回主界面 配置完成后进入VMware esxi WEB配置页面 在同个局域网中的另一台电脑浏览器输入vmware esxi主机的ip就可以访问了 第一次进来的画面 本教程到此结束]]></content>
      <categories>
        <category>VMware EXSI</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>EXSI</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FreeNAS如何安装]]></title>
    <url>%2Fposts%2F575cc893%2F</url>
    <content type="text"><![CDATA[======================================================= 《FreeNAS如何安装》 《FreeNAS-创建和删除卷》 《FreeNAS-创建SMB共享》 ======================================================= FreeNAS （free·nas [free-næs]），是一款开源免费的专门用于构建 NAS（Network Attached Storage）服务器的专业操作系统。 FreeNAS 可以轻松把一台普通的台式电脑变成存储服务器。它基于 FreeBSD 开发，在 BSD License 授权写一下发布，主要运行在 x86-64 架构的计算上。 FreeNAS 支持 Windows，macOS 和类 Unix 客户端，以及大量的虚拟化主机，例如 XenServer 和 VMware，支持 CIFS，AFP，NFS，iSCSI，SSH，rsync，WebDAV，以及 FTP/TFTP 等文件共享和传输协议。 FreeNAS 采用 ZFS 文件系统存储、管理和保护数据。ZFS 提供了诸如轻量级快照、压缩和重复数据删除等高级功能。可以快速的将数据增量备份到其他设备，带宽占用少，可有效帮助系统从故障中转移。 转载于：https://www.getnas.com/what-is-freenas/ 镜像下载地址：https://www.freenas.org/download-freenas-release/ 版本：FreeNAS 11.2-U2.1 需要64位CPU和至少8GB RAM 硬件使用：qotom 350p mini pc 开始进行安装 制作U盘启动 工具：Rufus 3.3 选择FreeNAS镜像后点开始制作 插入U盘，启动电脑，按F11，选择U盘启动 进入FreeNAS安装引导界面，按Enter 进入安装界面，选择1安装 选择安装系统的磁盘，空格设置为*，OK下一步 安装警告，无视，直接YES 设置密码，默认用户名为root 选择启动模式，根据BISO设置的启动模式选择，我的主板默认是UEFI，选择错误的话会启动不了，在BISO里修改为对应的启动模式就行了 安装完成后，选择reboot重启电脑，拔掉U盘 系统启动完成界面 进入WEB配置界面，默认账号为root，密码就是安装时设置的密码，IP为控制台显示的ip 安装完成，总的来说，FreeNAS安装还是很简单的]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Mini Pc</tag>
        <tag>Unix</tag>
        <tag>FreeNAS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pfsense端口转发设置]]></title>
    <url>%2Fposts%2F484f9c8b%2F</url>
    <content type="text"><![CDATA[Pfsense版本2.4.4-RELESE-p1 防火墙/地址转换/端口转发，新建规则策略 注意不要设置源端口，NAT回流启动（不开启回流，内部网络无法访问转发） 内部网络转发成功效果 外部转发，需要现用动态域名绑定外网ip，然后通过youddns:端口 访问 比如：what.ddns.net:5001]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>Pfsense</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pfsense网桥设置]]></title>
    <url>%2Fposts%2F8b7acdbb%2F</url>
    <content type="text"><![CDATA[硬件使用QOTOM Q500G6 MINIPC Web地址：192.168.1.1(默认) 账号/密码 admin/pfsense 一、桥接设置1.使用桥接网络将网口1-网口5分配成同一个网段，并且5个网口互通 2.默认LAN是绑定的igb1(192.168.1.1),可以先创建另外的网卡 3.绑定好接口后保存设置，（默认已经设置了DHCP范围） 这样LAN1-LAN3就会处于同一个网段 4.默认网口带了过滤器，网口不是互通的，需要修改参数 更改网桥过滤系统以禁用成员接口过滤：net.link.bridge.pfil_member = 0 更改网桥过滤系统以启用网桥接口过滤：net.link.bridge.pfil_bridge = 1 设置完成后重启下DHCP服务器，就能正常工作了 二、无线网卡设置（AR9565） 三、最终效果如下：]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>Pfsense</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Pfsense开启SSH]]></title>
    <url>%2Fposts%2F2c9bb733%2F</url>
    <content type="text"><![CDATA[使用PUTTY工具进行链接，下载地址： https://the.earth.li/~sgtatham/putty/latest/w32/putty.exe （32位） https://the.earth.li/~sgtatham/putty/0.70/w64/putty.exe （64位） Pfsense Web端配置： 进入系统-高级设置-管理员访问选项卡 选中’启用安全Shell’检查框 通过在“SSH端口”框中输入新的端口号来更改默认端口 单击页面底部的保存按钮应用更改并启动服务 ======================================================================================= ======================================================================================= Putty客服端配置： 运行Putty后，在顶部的主机框中输入pfSense路由器的LAN IP地址或主机名 如果将服务默认端口配置为其他端口，请将端口更改为在设置中输入的端口值 点击程序底部的“open”连接到服务器 默认账号为root，密码与管理员密码(默认pfsense)相同 更改系统管理员密码 要更改系统的root密码，请在系统菜单中打开用户管理。点击管理员用户旁边的编辑按钮更改密码。也可以在控制台里设置其他帐户。]]></content>
      <categories>
        <category>FreeBSD</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>Pfsense</tag>
        <tag>Firewall</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[QOTOM MINIPC 在Ubuntu下支持GPIO的方法]]></title>
    <url>%2Fposts%2F4227225b%2F</url>
    <content type="text"><![CDATA[QOTOM 迷你电脑 Ubuntu下支持GPIO的方法 电脑硬件型号：Q350P 问题：在使用在QOTOM Q350P迷你电脑时，发现安装ubuntu后，不能识别到GPIO。 cat /sys/kernel/debug/gpio 为空，这里通过安装驱动的方式尝试解决。 1.准备源代码12345cd /usr/srcroot@tiger:/usr/src# lslinux-4.19.23 linux-headers-4.15.0-45linux-headers-4.15.0-43 linux-headers-4.15.0-45-genericlinux-headers-4.15.0-43-generic 这里存放了系统内核源代码，linux-4.19.23是我单独下载的，这里使用4.19.23，直接使用系统自带的内核代码应该也是可以的。 下载地址：https://www.kernel.org/ 2.配置内核12root@tiger:/# cd usr/src/linux-4.19.23/root@tiger:/usr/src/linux-4.19.23# make menuconfig *Device Drivers * GPIO Support Port-mapped I/O GPIO drivers 通过GPIO说明书发现GPIO由TI8786E-1芯片处理，对IT87xx设置为[*] 然后save-&gt;Exit 3.编译并安装内核编译内核，具体编译方法可以参见另一篇博文《Ubuntu 18.04 上编译Linux内核》 1root@tiger:/usr/src/linux-4.19.23# make -j4 编译结束后，执行安装 12make modules_installmake install 因为我已经生成新的内核启动项了，这里直接重启就行了 1root@tiger:/usr/src/linux-4.19.23#shutdown -r now 4.验证结果新的内核已经能够识别到GPIO 在用户空间通过sysfs接口访问gpio正常 /sys/class/gpio使用说明:参考https://blog.csdn.net/u010871058/article/details/65648593 12345678910111213141516171、gpio_operation 通过/sys/文件接口操作IO端口 GPIO到文件系统的映射。2、控制GPIO的目录位于/sys/class/gpio。3、/sys/class/gpio/export 文件用于通知系统需要导出控制的GPIO引脚编号。4、/sys/class/gpio/unexport 用于通知系统取消导出。5、/sys/class/gpio/gpiochipX目录保存系统中GPIO寄存器的信息，包括每个寄存器控制引脚的起始编号base，寄存器名称label，引脚总数ngpio，导出一个引脚的操作步骤。6、首先计算此引脚编号，引脚编号 = 控制引脚的寄存器基数 + 控制引脚寄存器位数。7、向/sys/class/gpio/export写入此编号，比如12号引脚，echo 12 &gt; /sys/class/gpio/export，命令成功后生成/sys/class/gpio/gpio12目录，如果没有出现相应的目录，说明此引脚不可导出。8、direction文件，定义输入输出方向，可以通过下面命令定义为输出,direction接受的参数：in, out, high, low；high/low同时设置方向为输出。9、value文件是端口的数值，为1或0。 测试GPIO:通过查看说明书，得知使用的GPIO端口为80-87 1.找到对应的gpio编号 12345678910cat /sys/kernel/debug/gpio... gpio-504 (it87_gp80 ) gpio-505 (it87_gp81 ) gpio-506 (it87_gp82 ) gpio-507 (it87_gp83 ) gpio-508 (it87_gp84 ) gpio-509 (it87_gp85 ) gpio-510 (it87_gp86 ) gpio-511 (it87_gp87 ) 2.使用gp87端口，设置输出模式为输出 12root@tiger:/sys/class/gpio# echo 511 &gt; export root@tiger:/sys/class/gpio# echo out &gt; it87_gp87/direction 3.测试led 高电平熄灭 1root@tiger:/sys/class/gpio# echo 1 &gt; it87_gp87/value 低电平点亮 1root@tiger:/sys/class/gpio# echo 0 &gt; it87_gp87/value 附上测试脚本，led闪烁100次 12345678910111213#!bin/shCOUNTER=1echo 511 &gt; /sys/class/gpio/exportecho out &gt; /sys/class/gpio/it87_gp87/directionwhile [ &quot;$COUNTER&quot; -lt 100 ]; do echo &quot;gpio test ...:$COUNTER&quot; echo 1 &gt; /sys/class/gpio/it87_gp87/value sleep 0.3 echo 0 &gt; /sys/class/gpio/it87_gp87/value sleep 0.3 COUNTER=$(($COUNTER+1))done 最终效果图 简单方法：如果系统原始内核已经存在该驱动，直接加载驱动就可以了 insmod gpio_xxx.ko 永久生效：install -p -m 644 xxx.ko]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Mini Pc</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Ubuntu 18.04 上编译Linux内核]]></title>
    <url>%2Fposts%2F94d1595a%2F</url>
    <content type="text"><![CDATA[一、环境说明编译环境为Ubuntu18.04的工控电脑，QOTOM Q310P 二、编译步骤 下载内核源代码，地址：https://www.kernel.org/ 将下载好的文件linux-4.19.23.tar.xz解压 1tar -Jxf linux-4.19.23.tar.xz 将解压后的文件move到/usr/src/ 1sudo mv linux-4.19.23 /usr/src 安装必要依赖库（不同的版本可能会有所不同，原则是缺少什么装什么） 123456sudo apt-get install gcc make libncurses5-dev openssl libssl-dev sudo apt-get install build-essentialsudo apt-get install libelf-devsudo apt-get install libc6-devsudo apt-get install bisonsudo apt-get install flex 使用原内核配置文件,make menuconfig显示界面后exit退出，选择保存 12345sudo make mrproper #清除编译过程中产生的所有中间文件sudo make cleancd /usr/src/linux-4.19.23sudo cp /boot/config-4.15.0-45-generic .configsudo make menuconfig 开始进行编译,本人CPU双核4线程,编译时间取决电脑性能 1sudo make -j4 编译完成 三、安装内核 执行安装命令 12sudo make modules_install #安装内核模块sudo make install #安装内核 生成启动 123sudo mkinitramfs -o /boot/initrd.img-4.19.23 #make install已经自动生成了sudo update-initramfs -c -k 4.19.23 #创建initramfs镜像 make install已经自动生成了sudo update-grub2 #更新grub.cfg启动文件，会新增4.19.23内核的启动项 重启电脑，检验结果OK 123hch@tiger:~$ sudo shutdown -r nowhch@tiger:~$ uname -aLinux tiger 4.19.23 #1 SMP Wed Feb 20 16:50:39 CST 2019 x86_64 x86_64 x86_64 GNU/Linux]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt X86 编译教程]]></title>
    <url>%2Fposts%2F35104%2F</url>
    <content type="text"><![CDATA[准备编译环境一台用来编译的PC，一台多网卡的PC 这里我使用的QOTOM迷你电脑Q300P(Ubuntu编译openwrt镜像)和Q500G6(安装openwrt) 安装编译依赖库，重复包不会安装 1sudo apt-get install build-essential asciidoc binutils bzip2 gawk gettext git subversion libssl-dev libncurses5-dev patch unzip zlib1g-dev 如果是64位系统的话还需要安装32位兼容包(否则编译报错) 1sudo apt-get install libc6:i386 libgcc1:i386 libstdc++5:i386 libstdc++6:i386 编译源代码wopenwrt源：git clone https://github.com/openwrt/openwrt.git 更新最新的包定义 1./scripts/feeds update -a 安装所有的包 1./scripts/feeds install -a feeds命令将安装扩展代码包编译选项，如果不运行该命令，在menuconfig配置将没有选择这些扩展包的选项 安装更新之后，输入 make defconfig ，这个命令会检查所需的编译工具是否齐全，并生成默认的编译配置文件”.config” 开始配置编译固件， 输入 1make menuconfig targetsystem选择x86,target img我保持默认， 添加LuCI web配置 LuCI &gt; 1. Collections&gt;luci LuCI &gt; 2. Modules &gt; Translations———————–(zh-cn) LuCI &gt; 3. Applications&gt;luci-app-uhttpd 其他功能看自己需要 添加EXT4硬盘格式支持，Kernel modules &gt; Filesystem &gt; kmod-fs-ext4 添加USB支持，如不添加可能会不响应键盘，Kernel modules &gt; USB Support 下载所有已选择的软件代码压缩包(dl库)，openwrt仅有编译及配置指令，各种依赖的代码包在上游网站及代码仓库里，编译会下载大量源代码 1make download V=s 根据下载速度和选择的软件包数量，大约要3小时以上，翻墙会快很多… 注意使用root编译会报错，可以在/etc/profile 最后添加export FORCE_UNSAFE_CONFIGURE=1,然后执行 1source /etc/profile V=s 可以输出编译过程中每一步的执行动作，出错后显示详细错误信息，-j2使用两个线程并行编译，第一次不要用多线程编译，不好排错 1make V=s -j2 编译产生的中间文件会占用十几G，可以用make dirclean清除(会删除编译目录和编译工具目录) 12ulimit -s 10240 这个命令是防止爆栈make V=s -j线程数 速度比单线程快N倍 生成的文件在bin/x86/ 下 准备安装 接下来将镜像写入硬盘，我使用USB转MSATA，非常方便 1fdisk -l 找到要写入的盘，我的磁盘是/dev/sdb然后使用dd命令将写好的硬盘安装到PC，启动电脑 1dd if=openwrt-x86-generic-combined-ext4.img of=/dev/sdb 问题解决安装后，无法识别到网卡，这种情况应该是没有网卡驱动，只能找到对应的网卡驱动编译进内核了 make clean, 重新配置make menuconfig 经查找网卡使用的是Intel IG211-AT,走的是PCIE通道，这里要选用e1000e Kernel modules &gt; Network Devices将kmod-e1000e，kmod-igb驱动选中 本人手上有4个无线模块，在内核中添加无线网卡驱动 内核中的无线驱动只找到RTL8821AE的驱动 Kernel modules &gt; Wireless Drivers 保存配置文件因为之前已经编译过了，这次可以使用多线程，编译时间会快很多 12make cleanmake V=s -j4 重新编译OK，写入镜像后有线，无线网卡（RTL8821AE）均正常使用，其他无线网卡不识别，需要找到对应的驱动代码进行编译，加载到内核，以后有时间再研究]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt X86 安装教程]]></title>
    <url>%2Fposts%2Fea031ab5%2F</url>
    <content type="text"><![CDATA[硬件准备多网卡PC，使用QOTOM 6LAN 迷你电脑 交换机(非必须，这里只是为了方便)、网线、其他电脑一台 软件准备 Win32DiskImager镜像写入工具 Openwrt镜像下载地址：https://downloads.openwrt.org/releases/ 选择一个版本，然后点targets/x86/64/，来到下载列表 将镜像写入磁盘使用USB转msata线，不需要U盘做启动盘，直接用Win32DiskImager写入就行了 将写好镜像的磁盘安装到迷你电脑 WLAN接交换机，LAN接另一台电脑（配置web需要） 安装好后开机，选择第一项 启动完成界面，输入passwd配置初始密码 默认eth0是LAN,这里与我的接线相反（喜欢第一个口做WAN），修改下network vim /etc/config/network /etc/init.d/network restart 重启服务 如果LAN口还是获取不到Ip，可以重启DHCP服务试试，/etc/init.d/dnsmasq restart 重启后grub没有倒计时，经google后发现是默认需要串行接口，注释掉后就会展示倒计时了 注意/boot分区默认是只读的，需要重新挂载为可读写 1mount -o rw,remount /boot LAN默认账号为root，密码为空，输入passwd修改默认密码 然后在接LAN的电脑浏览器输入192.168.1.1登录web配置页面 将另外的网卡桥接起来，这样就都能使用了（同一网段） 更新包列表 1opkg update 安装中文语言包 System-Software–Software-Actions，在Download and install package右边的文本框里输入：luci-i18n-base-zh-cn，点击OK 安装完后到语言设置的位置选择chinese，然后刷新页面即可 到此，OpenWrt的大门已为你敞开。接下来，开始尝试利用OpenWrt实现更多智能应用吧，比如单号多拨榨取运营商带宽、绑定域名远程控制、挂载大容量硬盘、搭建BT下载机、搭建网络摄像头、Samba/DLNA家庭NAS共享、私有云同步、FTP、个人网站/服务器]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[OpenWrt RTL8211AE 无线网卡设置]]></title>
    <url>%2Fposts%2F49536858%2F</url>
    <content type="text"><![CDATA[无线网卡：RTL8821AE 先查看无线网卡支持的信道Ssh连接到Openwrt,输入iw list 这里主要讲两种最简单的设置方式：第一种无线桥接LAN网络，这种最简单，配好基本就能正常上网了 如果无线安全选项没有加密方式可选 1.需要安装Hostapd做为AP模式 可以使用WPA2加密 2.如果做为客户端加密便需要 用到 wpa-supplican 123opkg update 更新软件列表opkg install hostapdopkg install wpa-supplicant 第二种：这种无线为独立的网关这里我选用2.4G频宽，信道13 无线安全推荐选用WPA2-PSK,其他使用默认设置 接下来绑定网卡，点击网络—-接口—-添加新接口 设置IP地址，默认开启DHCP 最后设置下防火墙就可以上网了]]></content>
      <categories>
        <category>OpenWrt</category>
      </categories>
      <tags>
        <tag>Router</tag>
        <tag>OpenWrt</tag>
        <tag>LEDE</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux使用STM官方库开发]]></title>
    <url>%2Fposts%2F6a72ce9%2F</url>
    <content type="text"><![CDATA[PC：Ubuntu 18.04.1，开发板：STM32F103C8T6 使用交叉编译器：gcc-arm-none-eabi 1apt-get install gcc-arm-none-eabi 安装完成后输入arm-none-eabi- 然后按tab键看到很多文件 说明安装成功了详细可以看我另两篇博文 下载stm32固件库www.st.com/zh 下载，并解压（~/stm32/codes/stm_project） 12root@tiger:~/stm32/codes# lsen.stsw-stm32054.zip 创建目录libs目录放stm32固件库，src放用户源码，inc放用户头文件 12root@tiger:~/stm32/codes/stm_project# lsinc libs src 创建Makefile.common在主目录下创建Makefile.common文件，这个是通用Makefile文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100# include Makefile #This file is included in the general Makefile, the libs Makefile and the src Makefile#Different optimize settings for library and source files can be realized by using arguments#Compiler optimize settings:# -O0 no optimize, reduce compilation time and make debugging produce the expected results (default).# -O1 optimize, reduce code size and execution time, without much increase of compilation time.# -O2 optimize, reduce code execution time compared to ‘O1’, increase of compilation time.# -O3 optimize, turns on all optimizations, further increase of compilation time.# -Os optimize for size, enables all ‘-O2’ optimizations that do not typically increase code size and other code size optimizations.#Recommended optimize settings for release version: -O3#Recommended optimize settings for debug version: -O0#Valid parameters :# OptLIB=0 --&gt; optimize library files using the -O0 setting# OptLIB=1 --&gt; optimize library files using the -O1 setting# OptLIB=2 --&gt; optimize library files using the -O2 setting# OptLIB=3 --&gt; optimize library files using the -O3 setting# OptLIB=s --&gt; optimize library files using the -Os setting# OptSRC=0 --&gt; optimize source files using the -O0 setting# OptSRC=1 --&gt; optimize source files using the -O1 setting# OptSRC=2 --&gt; optimize source files using the -O2 setting# OptSRC=3 --&gt; optimize source files using the -O3 setting# OptSRC=s --&gt; optimize source files using the -Os setting# all --&gt; build all# libs --&gt; build libs only# src --&gt; build src only# clean --&gt; clean project# tshow --&gt; show optimize settings#Example:# make OptLIB=3 OptSRC=0 all tshow TOP=$(shell readlink -f &quot;$(dir $(lastword $(MAKEFILE_LIST)))&quot;)PROGRAM=mainLIBDIR=$(TOP)/libs #Adust the following line to the library in use#=========add by hch 根据你的库不同,调整这个地方的库目录地址====================#STMLIB=$(LIBDIR)/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries#=========add by hch 根据你的stm32芯片型号容量不同,修改这个地方的TypeOfMCU=======##Adjust TypeOfMCU in use, see CMSIS file &quot;stm32f10x.h&quot;#STM32F103RBT (128KB FLASH, 20KB RAM) --&gt; STM32F10X_MD#TypeOfMCU=STM32F10X_MD#STM32F103RET (512KB FLASH, 64KB RAM) --&gt; STM32F10X_HD#STM32F103ZET (512KB FLASH, 64KB RAM) --&gt; STM32F10X_HD:#============================================================================#TypeOfMCU=STM32F10X_MD#============================================================================#TC=arm-none-eabiCC=$(TC)-gccLD=$(TC)-ld -vOBJCOPY=$(TC)-objcopyAR=$(TC)-arGDB=$(TC)-gdbINCLUDE=-I$(TOP)/incINCLUDE+=-I$(STMLIB)/CMSIS/CM3/CoreSupportINCLUDE+=-I$(STMLIB)/CMSIS/CM3/DeviceSupport/ST/STM32F10xINCLUDE+=-I$(STMLIB)/STM32F10x_StdPeriph_Driver/incCOMMONFLAGS=-g -mcpu=cortex-m3 -mthumbCOMMONFLAGSlib=$(COMMONFLAGS)#Commands for general Makefile and src Makefileifeq ($(OptSRC),0) COMMONFLAGS+=-O0 InfoTextSrc=src (no optimize, -O0)else ifeq ($(OptSRC),1) COMMONFLAGS+=-O1 InfoTextSrc=src (optimize time+ size+, -O1)else ifeq ($(OptSRC),2) COMMONFLAGS+=-O2 InfoTextSrc=src (optimize time++ size+, -O2)else ifeq ($(OptSRC),s) &amp;nbsp;COMMONFLAGS+=-Os InfoTextSrc=src (optimize size++, -Os)else COMMONFLAGS+=-O3 InfoTextSrc=src (full optimize, -O3)endifCFLAGS+=$(COMMONFLAGS) -Wall -Werror $(INCLUDE)CFLAGS+=-D $(TypeOfMCU)CFLAGS+=-D VECT_TAB_FLASH #Commands for libs Makefileifeq ($(OptLIB),0) COMMONFLAGSlib+=-O0 InfoTextLib=libs (no optimize, -O0)else ifeq ($(OptLIB),1) COMMONFLAGSlib+=-O1 InfoTextLib=libs (optimize time+ size+, -O1)else ifeq ($(OptLIB),2) COMMONFLAGSlib+=-O2 InfoTextLib=libs (optimize time++ size+, -O2)else ifeq ($(OptLIB),s) COMMONFLAGSlib+=-Os InfoTextLib=libs (optimize size++, -Os)else COMMONFLAGSlib+=-O3 InfoTextLib=libs (full optimize, -O3)endifCFLAGSlib+=$(COMMONFLAGSlib) -Wall -Werror $(INCLUDE)CFLAGSlib+=-D $(TypeOfMCU)CFLAGSlib+=-D VECT_TAB_FLASH 编译固件库 1.首先编译固件库，将固件库编译成静态库，应用程序可以直接使用. 2.下载startup.c，路径：stm_project/libs/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/ CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/ 3.编写Makefile文件，路径：stm_project/libs/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/ STM32F10x_StdPeriph_Driver/src 1234567891011121314151617181920212223242526272829include ../../../../../Makefile.commonLIBS+=libstm32.aCFLAGSlib+=-c all: $(LIBS)libstm32.a: @echo -n &quot;Building $@ ...&quot; cd $(STMLIB)/CMSIS/CM3/DeviceSupport/ST/STM32F10x/ &amp;&amp; \ $(CC) $(CFLAGSlib) system_stm32f10x.c cd $(STMLIB)/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm &amp;&amp; \ $(CC) $(CFLAGSlib) startup.c cd $(STMLIB)/STM32F10x_StdPeriph_Driver/src &amp;&amp; \ $(CC) $(CFLAGSlib) *.c \ -D&quot;assert_param(expr)=((void)0)&quot; $(AR) cr $(LIBDIR)/$@ \ $(STMLIB)/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.o \ $(STMLIB)/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup.o \ $(STMLIB)/STM32F10x_StdPeriph_Driver/src/*.o @echo &quot;done.&quot;.PHONY: clean clean: rm -f $(STMLIB)/CMSIS/CM3/DeviceSupport/ST/STM32F10x/system_stm32f10x.o rm -f $(STMLIB)/CMSIS/CM3/DeviceSupport/ST/STM32F10x/startup/arm/startup.o rm -f $(STMLIB)/STM32F10x_StdPeriph_Driver/src/*.o rm -f $(LIBDIR)/$(LIBS) 建立ld文件项目根目录建立linker.ld文件，根据芯片的内存以及flash容量下面是文件需要修改的地方 12345678910111213141516171819202122MEMORY &#123; /*Adust LENGTH to RAMsize of target MCU:*/ /*STM32F103RBT --&gt; 20K*/ RAM (RWX) : ORIGIN = 0x20000000 , LENGTH = 20K /*STM32F103RET --&gt; 64K*/ /*STM32F103ZET --&gt; 64K*/ /*RAM (RWX) : ORIGIN = 0x20000000 , LENGTH = 64K*/ EXTSRAM (RWX) : ORIGIN = 0x68000000 , LENGTH = 0 /*Adust LENGTH to (FLASHsize - FeePROMsize) of target MCU:*/ /*STM32F103RBT --&gt; 126K*/ /*FLASH (RX) : ORIGIN = 0x08000000 , LENGTH = 126K*/ /*STM32F103RET --&gt; 508K*/ /*FLASH (RX) : ORIGIN = 0x08000000 , LENGTH = 508K*/ /*STM32F103ZET --&gt; 508K*/ FLASH (RX) : ORIGIN = 0x08000000 , LENGTH = 508K /*Adust ORIGIN to (0x08000000 + (FLASHsize-FeePROMsize)) of target MCU*/ /*and adust LENGTH to FeePROMsize allocated:*/ /*STM32F103RBT --&gt; 0x08000000+126K, 2K*/ EEMUL (RWX) : ORIGIN = 0x08000000+126K, LENGTH = 2K /*STM32F103RET --&gt; 0x08000000+508K, 4K*/ /*EEMUL (RWX) : ORIGIN = 0x08000000+508K, LENGTH = 4K*/&#125; 编译用户文件将用户应用程序也编译成静态库~/stm32/codes/stm_project/src/Makefile 123456789101112131415161718include ../Makefile.commonLIBS+=app.aCFLAGSlib+=-call: $(LIBS)app.a: @echo -n &quot;Building $@ ...&quot; $(CC) $(CFLAGSlib) *.c $(AR) cr $@ *.o @echo &quot;done.&quot;.PHONY: cleanclean: rm -f *.o rm -f $(LIBS) 建立主Makefile在主目录下，建立主Makefile文件将固件库和用户应用程序编译成可执行文件 12345678910111213141516171819202122232425262728293031include Makefile.commonLDFLAGS=$(COMMONFLAGS) -fno-exceptions -ffunction-sections -fdata-sections -L$(LIBDIR) -nostartfiles -Wl,--gc-sections,-Tlinker.ld LDLIBS+=-lmLDLIBS+=-lstm32 STARTUP=startup.c all: libs src $(CC) -o $(PROGRAM).elf $(LDFLAGS) \ -Wl,--whole-archive \ src/app.a \ -Wl,--no-whole-archive \ $(LDLIBS) $(OBJCOPY) -O ihex $(PROGRAM).elf $(PROGRAM).hex $(OBJCOPY) -O binary $(PROGRAM).elf $(PROGRAM).bin arm-none-eabi-readelf -a $(PROGRAM).elf &gt; $(PROGRAM).info_elf arm-none-eabi-size -d -B -t $(PROGRAM).elf &gt; $(PROGRAM).info_size arm-none-eabi-objdump -S $(PROGRAM).elf &gt; $(PROGRAM).info_code arm-none-eabi-nm -t d -S --size-sort -s $(PROGRAM).elf &gt; $(PROGRAM).info_symbol .PHONY: libs src clean libs: $(MAKE) -C libs/STM32F10x_StdPeriph_Lib_V3.5.0/Libraries/STM32F10x_StdPeriph_Driver/srcsrc: $(MAKE) -C srcclean: rm -f $(PROGRAM).elf $(PROGRAM).hex $(PROGRAM).bin $(PROGRAM).info_elf $(PROGRAM).info_size rm -f $(PROGRAM).info_code rm -f $(PROGRAM).info_symbol 根目录执行make生成二进制文件 123root@tiger:~/stm32/codes/stm_project# lsinc linker.ld main.elf main.info_code main.info_size Makefile srclibs main.bin main.hex main.info_elf main.info_symbol Makefile.common loadbin烧写程序OK，输入r复位，g运行程序 1234567891011121314151617181920J-Link&gt;loadbin /home/hch/stm32/codes/stm_project/main.bin 0x8000000**************************WARNING: T-bit of XPSR is 0 but should be 1. Changed to 1.**************************Downloading file [/home/hch/stm32/codes/stm_project/main.bin]...Comparing flash [100%] Done.Erasing flash [100%] Done.Programming flash [100%] Done.Verifying flash [100%] Done.J-Link: Flash download: Bank 0 @ 0x08000000: 1 range affected (5120 bytes)J-Link: Flash download: Total time needed: 0.281s (Prepare: 0.025s, Compare: 0.004s, Erase: 0.111s, Program: 0.135s, Verify: 0.000s, Restore: 0.003s)O.K.J-Link&gt;rReset delay: 0 msReset type NORMAL: Resets core &amp; peripherals via SYSRESETREQ &amp; VECTRESET bit.Reset: Halt core after reset via DEMCR.VC_CORERESET.Reset: Reset device via AIRCR.SYSRESETREQ.J-Link&gt;g 项目源代码：https://github.com/huchanghui123/stm32_linux.git]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下编译、烧写RT-Rhread，基于STM32单片机]]></title>
    <url>%2Fposts%2F79c57df1%2F</url>
    <content type="text"><![CDATA[PC：Ubuntu18（64位），开发板STM32F103RE，JLink V9，RT_Thread V2.01，第一步安装交叉编译器， 直接命令行输入 apt-get install gcc-arm-none-eabi 2，安装完成后，输入arm-none-eabi- 然后TAB键，可以看到好多东西，说明已经安装成功了 3，git下载rt-thread代码，此处就不详细讲解下载过程了 12GitHub 的下载链接：https://github.com/RT-Thread/rt-threadGitee 的下载链接：https://gitee.com/rtthread/rt-thread 4，开始编译啦，首先需要配置 rtconfig.py文件， vim 编译器打开，修改如下地方,因为我们是在Linux下开发，所以也没KEIL、IAR什么事情，利用第一步安装的交叉编译环境 123编译代码，CROSS_TOOL = &apos;gcc&apos;EXEC_PATH=&apos;/opt&apos;PREFIX = &apos;arm-none-eabi-&apos; 保存修改，然后退出 vim 5，开始正式编译勒，~/stm32/codes/rt-thread/bsp/stm32f10x目录下执行 sudo scons ,开始编译代码，编译结束后出现执行文件大小等内容，此时查看stm32f103x 目录下会出现图中绿色可执行文件， .bin就是我们下一步需要烧写的文件 6，然后回到JLINK连接开发板内容，找到SEEGER目录下执行 ./JLinkExe ，然后connect开发板，选择芯片、调试模式、下载速度等6，然后回到昨天的JLINK连接开发板内容，找到SEEGER目录下执行 ./JLinkExe ，然后connect开发板，选择芯片、调试模式、下载速度等 7，然后可以开始下载二进制代码啦，执行 loadbin /home/hch/stm32/codes/rt-thread/bsp/stm32f10x/rtthread.bin 0x8000000 命令，其中 loadbin 是命令字，然后是执行代码的地址，最后是stm32的falsh起始地址，输入命令后，可以看到烧写过程，有falsh对比、擦出、写入、验证四个过程，烧写速度很快，体验非常赞，显示 OK后烧写完成，复位 处理器以后程序就开始运行了。]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下使用STM32F103C8]]></title>
    <url>%2Fposts%2F9493c811%2F</url>
    <content type="text"><![CDATA[ubuntu18.04.1(x64) 使用STM32F103C81.板子使用JLINK烧写程序，需要先安装JLINK驱动（V9） SEGGER官网下载最新jlink驱动，网址 https://www.segger.com/downloads/jlink JLinkExe会用到libreadline库，所以得把libreadline库装上。http://cnswww.cns.cwru.edu/php/chet/readline/rltop.html 中Current Status选择下载，并安装，如下所示： 1234tar -zxvf readline-6.2.tar.gz./configuremakemake install 2.Jlink安装好啦，找到 /opt目录下/opt/SEGGER/JLink，说明驱动已经安装 3.执行./JLinkExe 进入JLink命令行模式，出现下图 4.输入cconnect，如果设备显示 Unspecified，要先设置目标处理器，否则无法正常烧写，我的型号是STM32F103C8T6，这里只能输入 1J-Link&gt;exec device=STM32F103C8 4.下载loadbin loadbin用于将二进制文件下载到目标存储器，语法如下： 1Syntax: loadbin &lt;filename&gt;, &lt;addr&gt; //Load binary file into target memory 有个麻烦，下载完没有明显提示成功与否，可以通过这样解决：在PC通过命令xxd查看待下载文件，下载进去通过JLink命令mem查看，判断这两者是否一样(只比较前面若干字节即可)，若一样，则表示烧写成功。举个例子，把/bin/cp文件烧到板子： 12345678910111213J-Link&gt;loadbin /bin/xxx.bin 0x08000000Loading binary file... [/bin/cp]Writing bin data into target memory @ 0x08000000.J-Link&gt;mem 0x08000000,3f08000000 = 7F 45 4C 46 01 01 01 00 00 00 00 00 00 00 00 0008000010 = 02 00 03 00 01 00 00 00 40 A1 04 08 34 00 00 0008000020 = 04 73 01 00 00 00 00 00 34 00 20 00 09 00 28 0008000030 = 1D 00 1C 00 06 00 00 00 34 00 00 00 34 80 04root@tiger:~$ xxd /bin/xxx.bin | more0000000: 7f45 4c46 0101 0100 0000 0000 0000 0000 .ELF............0000010: 0200 0300 0100 0000 40a1 0408 3400 0000 ........@...4...0000020: 0473 0100 0000 0000 3400 2000 0900 2800 .s......4. ...(.0000030: 1d00 1c00 0600 0000 3400 0000 3480 0408 ........4...4... 3.2 保存savebin 1Syntax: savebin &lt;filename&gt;, &lt;addr&gt;, &lt;NumBytes&gt; //Saves target memory into binary file 这里值得一提的是，参数是十六进制，比如指定10，保存的是16个字节。 命令mem的也是十六进制的。]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>Ubuntu</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下搭建FTP服务器]]></title>
    <url>%2Fposts%2F18969901%2F</url>
    <content type="text"><![CDATA[Linux下搭建FTP服务器(Ubuntu 18.04.1)步骤：1.安装vsftpd软件包 1sudo apt-get install vsftpd 2.打开配置文件 1vim /etc/vsftpd.conf 3.修改参数 一些参数可以去掉注释激活，为了方便，默认设置我全不管，然后添加下面的设置 12345678910111213141516171819202122232425262728293031323334353637#这些设置系统默认是开启的，可以不管listen=NOlisten_ipv6=YESdirmessage_enable=YESuse_localtime=YESxferlog_enable=YESconnect_from_port_20=YES#下面的就要自定义设置了，建议系统默认的不管，然后复制下面的#是否允许匿名访问，NO为不允许anonymous_enable=NO#是否允许本地用户访问,就是linux本机中存在的用户，YES允许local_enable=YES#是否开启写模式，YES为开启write_enable=YES#新建文件权限，一般设置为022，那么新建后的文件的权限就是777-022=755local_umask=022#是否启动userlist为通过模式，YES的话只有存在于userlist文件中的用户才能登录ftp（可以理解为userlist是一个白名单），NO的话，白名单失效，和下面一个参数配合使用userlist_enable=YES#是否启动userlist为禁止模式，YES表示在userlist中的用户禁止登录ftp（黑名单），NO表示黑名单失效，我们已经让userlist作为一个白名单，所以无需使用黑名单功能userlist_deny=NO#指定哪个文件作为userlist文件，我们稍后编辑这个文件userlist_file=/etc/vsftpd.user_list#是否限制本地所有用户切换根目录的权限，YES为开启限制，即登录后的用户不能访问ftp根目录以外的目录，当然要限制啦chroot_local_user=YES#是否启动限制用户的名单list为允许模式，上面的YES限制了所有用户，可以用这个名单作为白名单，作为例外允许访问ftp根目录以外chroot_list_enable=YES#设置哪个文件是list文件，里面的用户将不受限制的去访问ftp根目录以外的目录chroot_list_file=/etc/vsftpd.chroot_list#是否开启写模式，开启后可以进行创建文件夹等写入操作allow_writeable_chroot=YES#设置ftp根目录的位置,这个文件我们稍后自己创建local_root=/var/myftp 重启vsftpd 1sudo /etc/init.d/vsftpd restart 4.添加ftp用户 顺便将将用户目录设置为我们上面的ftp根目录 1sudo useradd -d /var/myftp xxxuser 设置用户密码 1sudo passwd xxxpwd 5.创建需要的文件，设置文件夹权限 上面我们指定了两个文件，userlist文件和list文件，系统不会自动创建，你要自己创建 1vim /etc/vsftpd.user_list 然后添加ftpuser进去作为白名单的一员 1vim /etc/vsftpd.chroot_list 设为空即可 创建用户文件夹，设置权限 1mkdir /var/myftp 权限设置可以根据你的使用场景来设置，我这里在根目录下禁止此用户写，然后下面建两个文件夹，一个download只允许读取，upload允许写和读 123456chmod 555 /var/myftpcd /var/myftpmkdir uploadchmod 755 uploadmkdir downloadchmod 555 download 最后检查一下文件所有者，都改为xxxuser，命令chown xxxuser download/upload 6.使用ftp，解决各种问题 linux访问输入ftp 加 你的IP 1ftp xxx.xxx.xxx.xxx 输入用户名xxxuser和密码 如果登录出现530错误： 1vim /etc/pam.d/vsftpd 注释掉#auth required pam_shells.so 然后ls一下，如果失败了，切换到被动模式即可 1passive mode 然后mkdir一下发现无法创建文件夹 550 create directory operation failed 输入以下指令即可 12setsebool -P ftpd_disable_trans on/etc/init.d/vsftpd restart]]></content>
      <categories>
        <category>Linux</category>
      </categories>
  </entry>
</search>
